"use client";
import React from "react"; // React import hinzugef√ºgt
import { useEffect, useState, useRef, useMemo } from "react";
import { ref, getDownloadURL } from "firebase/storage";
import { storage } from "../../lib/firebase";
// --- Cached getDownloadURL with memory + localStorage TTL ---
const __dlMem = new Map<string, { url: string; exp: number }>();
const DL_TTL_MS = 24 * 60 * 60 * 1000; // 24h
function lsGet(k: string) {
  try { const s = localStorage.getItem(k); return s ? JSON.parse(s) : null; } catch { return null; }
}
function lsSet(k: string, v: any) {
  try { localStorage.setItem(k, JSON.stringify(v)); } catch {}
}
async function getCachedDownloadURL(path: string): Promise<string> {
  // passthrough for absolute URLs and Next.js public assets (starting with "/")
  if (/^https?:\/\//i.test(path) || path.startsWith('/')) return path;
  const now = Date.now();
  const mem = __dlMem.get(path);
  if (mem && mem.exp > now) return mem.url;
  const k = `dl:${path}`;
  const st = lsGet(k);
  if (st && st.url && typeof st.exp === 'number' && st.exp > now) {
    __dlMem.set(path, { url: st.url, exp: st.exp });
    return st.url;
  }
  const url = await getDownloadURL(ref(storage, path));
  const exp = now + DL_TTL_MS;
  const rec = { url, exp };
  __dlMem.set(path, rec);
  lsSet(k, rec);
  return url;
}

// Slugify a name for local asset lookup (e.g. "Amazon Karte" -> "amazon-karte.png")
function toSlugFilename(name?: string | null): string | null {
  if (!name || typeof name !== 'string') return null;
  const slug = name
    .toLowerCase()
    .normalize('NFKD')
    .replace(/[^\w\s-]+/g, '')
    .trim()
    .replace(/[\s_-]+/g, '-')
    .replace(/^-+|-+$/g, '');
  return slug ? `${slug}.png` : null;
}

// Weekly cache-busting for avatar images
function weekStamp() { return Math.floor(Date.now() / (7 * 24 * 60 * 60 * 1000)); }
// --- Mark that a minigame was started from the Drop screen (client-side token) ---
function markDropStart() {
  try { 
    const now = Date.now();
    sessionStorage.setItem('drop.startedFromDrop', String(now)); 
    console.log('[markDropStart] Token set:', now);
  } catch (e) {
    console.error('[markDropStart] Failed to set token:', e);
  }
}
function withAvatarCache(u?: string | null) {
  if (!u) return null;
  const sep = u.includes('?') ? '&' : '?';
  return `${u}${sep}wk=${weekStamp()}`;
}

const berlinPartsFormatter = new Intl.DateTimeFormat('en-CA', {
  timeZone: 'Europe/Berlin',
  year: 'numeric',
  month: '2-digit',
  day: '2-digit',
  hour: '2-digit',
  minute: '2-digit',
  second: '2-digit',
  hour12: false, // FIX: Force 24-hour format instead of 12-hour (8:45 vs 20:45)
});

function berlinPartsFromMs(ms: number) {
  const parts = berlinPartsFormatter.formatToParts(new Date(ms));
  const map: Record<string, string> = {};
  for (const part of parts) {
    if (part.type !== 'literal') map[part.type] = part.value;
  }
  return {
    year: Number(map.year || '0'),
    month: Number(map.month || '0'),
    day: Number(map.day || '0'),
    hour: Number(map.hour || '0'),
    minute: Number(map.minute || '0'),
    second: Number(map.second || '0'),
  };
}

function formatBerlinDay(parts: { year: number; month: number; day: number }) {
  return `${parts.year}-${String(parts.month).padStart(2, '0')}-${String(parts.day).padStart(2, '0')}`;
}

function shiftBerlinDay(parts: { year: number; month: number; day: number }, delta: number) {
  const base = new Date(Date.UTC(parts.year, parts.month - 1, parts.day));
  base.setUTCDate(base.getUTCDate() + delta);
  return { year: base.getUTCFullYear(), month: base.getUTCMonth() + 1, day: base.getUTCDate() };
}

function raffleCollectionDateIdFromMs(ms: number): string {
  const parts = berlinPartsFromMs(ms);
  const minutes = parts.hour * 60 + parts.minute + parts.second / 60;
  const cutoff = 20 * 60;
  let target = { year: parts.year, month: parts.month, day: parts.day };
  if (minutes >= cutoff) {
    target = shiftBerlinDay(target, 1);
  }
  return formatBerlinDay(target);
}

function raffleDrawDateIdFromMs(ms: number): string {
  const parts = berlinPartsFromMs(ms);
  const minutes = parts.hour * 60 + parts.minute + parts.second / 60;
  const cutoff = 20 * 60;
  let target = { year: parts.year, month: parts.month, day: parts.day };
  if (minutes < cutoff) {
    target = shiftBerlinDay(target, -1);
  }
  return formatBerlinDay(target);
}

function winnersDisplayDateIdFromMs(ms: number): string {
  const parts = berlinPartsFromMs(ms);
  // NEW LOGIC: Show YESTERDAY's winners by default, only show TODAY's after 20:15
  const minutes = parts.hour * 60 + parts.minute;
  const cutoff = 20 * 60 + 15; // 20:15 Berlin time
  let target = { year: parts.year, month: parts.month, day: parts.day };
  
  // Before 20:15: Show yesterday's winners (because today's raffle hasn't happened yet)
  // After 20:15: Show today's winners (new raffle results available)
  if (minutes < cutoff) {
    target = shiftBerlinDay(target, -1); // Show yesterday's winners before 20:15
  }
  // After 20:15: show today's winners (default = today)
  
  // Debug logging for winner display timing
  const timeStr = `${String(parts.hour).padStart(2,'0')}:${String(parts.minute).padStart(2,'0')}:${String(parts.second).padStart(2,'0')}`;
  const resultDate = formatBerlinDay(target);
  console.log(`[winnersDisplayDateIdFromMs] NEW LOGIC Berlin: ${timeStr}, minutes: ${minutes}, < ${cutoff}? ${minutes < cutoff}, result: ${resultDate}`);
  
  return resultDate;
}
import { getFirestore, doc, onSnapshot, getDoc, getDocFromServer, runTransaction, serverTimestamp, collectionGroup, query as fsQuery, where, getDocs, documentId, writeBatch } from "firebase/firestore";
// --- Raffle Test Terminal (client-only, read-only) ---
function RaffleTestTerminal({
  onClose,
  forceRaffleWindow, 
  onForceRaffleWindowChange
}: {
  onClose: () => void;
  forceRaffleWindow: boolean;
  onForceRaffleWindowChange: (next: boolean) => void;
}) {
  const [dateId, setDateId] = useState<string>(() => raffleCollectionDateIdFromMs(Date.now()));
  const [seed, setSeed] = useState<string>(() => Math.random().toString(36).slice(2, 10));
  const [prizesText, setPrizesText] = useState<string>('[{"amount":5,"count":10},{"amount":20,"count":2}]');
  const [entrants, setEntrants] = useState<Array<{ uid: string; w: number }>>([]);
  const [winners, setWinners] = useState<Array<{ uid: string; amount: number }>>([]);
  const [loading, setLoading] = useState<boolean>(false);
  const [seeding, setSeeding] = useState<boolean>(false);
  const [seedInfo, setSeedInfo] = useState<{ code?: string; message?: string; debug?: string } | null>(null);
  const [raffleInfo, setRaffleInfo] = useState<{ dateId?: string; levelKey?: string; winners?: Record<string, { name: string; prize: string }> } | null>(null);
  const [raffleBusy, setRaffleBusy] = useState(false);
  const [grantBusy, setGrantBusy] = useState(false);
  const [grantInfo, setGrantInfo] = useState<string | null>(null);

  // tiny deterministic RNG based on string seed
  function xmur3(str: string) { let h = 1779033703 ^ str.length; for (let i = 0; i < str.length; i++) { h = Math.imul(h ^ str.charCodeAt(i), 3432918353); h = (h << 13) | (h >>> 19); } return function () { h = Math.imul(h ^ (h >>> 16), 2246822507); h = Math.imul(h ^ (h >>> 13), 3266489909); return (h ^ (h >>> 16)) >>> 0; }; }
  function mulberry32(a: number) { return function () { let t = (a += 0x6D2B79F5); t = Math.imul(t ^ (t >>> 15), 1 | t); t ^= t + Math.imul(t ^ (t >>> 7), 61 | t); return ((t ^ (t >>> 14)) >>> 0) / 4294967296; }; }
  function detRand(uid: string, salt: string, seedStr: string) { const s = xmur3(`${seedStr}|${uid}|${salt}`)(); return mulberry32(s)(); }

  function weightedSampleWithoutReplacement(ents: Array<{ uid: string; w: number }>, k: number, seedStr: string, salt: string) {
    const scored = ents.map(e => {
      const u = Math.max(1e-12, detRand(e.uid, salt, seedStr));
      const key = Math.pow(u, 1 / Math.max(1, e.w));
      return { uid: e.uid, key };
    });
    scored.sort((a, b) => b.key - a.key);
    return scored.slice(0, k).map(s => s.uid);
  }

  function parsePrizes(): Array<{ amount: number; count: number }> {
    try {
      const arr = JSON.parse(prizesText);
      if (Array.isArray(arr)) return arr.map((p: any) => ({ amount: Number(p.amount) || 0, count: Number(p.count) || 0 })).filter(p => p.count > 0);
    } catch {}
    return [];
  }

  async function loadEntrants() {
    setLoading(true);
    try {
      const fs = getFirestore();
      // Note: documentId() requires full document paths in collectionGroup queries.
      // For the test terminal, filter by doc.id clientseitig.
      const q = fsQuery(
        collectionGroup(fs, 'countersByDay'),
        where('tickets', '>', 0)
      );
      const snap = await getDocs(q);
      const arr: Array<{ uid: string; w: number }> = [];
      snap.forEach(docSnap => {
        const t = Number(docSnap.get('tickets') || 0);
        const uid = docSnap.ref.parent?.parent?.id;
        if (uid && t > 0 && docSnap.id === dateId) arr.push({ uid, w: t });
      });
      setEntrants(arr);
      setWinners([]);
    } finally {
      setLoading(false);
    }
  }


  function runSim() {
    const totalTickets = entrants.reduce((s, e) => s + e.w, 0);
    const prizes = parsePrizes();
    const totalSlots = prizes.reduce((s, p) => s + (p.count || 0), 0);
    const k = Math.min(totalSlots, entrants.length);
    const ids = weightedSampleWithoutReplacement(entrants, k, seed, 'slot-allocation');
    const slots: number[] = [];
    prizes.sort((a, b) => (b.amount || 0) - (a.amount || 0)).forEach(p => { for (let i = 0; i < p.count; i++) slots.push(p.amount); });
    const out = ids.map((uid, i) => ({ uid, amount: slots[i] ?? 0 }));
    setWinners(out);
  }

  async function runCloudRaffle() {
    setRaffleBusy(true);
    setSeedInfo(null);
    try {
      const fn = httpsCallable(getFunctions(undefined, 'us-central1'), 'runRaffleNow');
      const res: any = await fn({ dateId });
      console.log('[runRaffleNow] raw response', res);
      const data = res?.data || {};
      console.log('[runRaffleNow] data', data);
      const dbg = (() => { try { return JSON.stringify(data, null, 2); } catch { return String(data); } })();
      if (data.ok) {
        setRaffleInfo({ dateId: data.dateId, levelKey: data.levelKey, winners: data.winners || {} });
        setSeedInfo({ code: 'ok', message: `Cloud: ${Object.keys(data.winners || {}).length} Gewinner gespeichert (Level ${data.levelKey || '?'})`, debug: dbg });
        await loadEntrants();
        setWinners([]);
      } else {
        setRaffleInfo(null);
        setSeedInfo({ code: data.code || 'error', message: data.message || 'Cloud-Raffle fehlgeschlagen', debug: dbg });
      }
    } catch (e: any) {
      setRaffleInfo(null);
      const edbg = (() => { try { return JSON.stringify({ code: e?.code, message: e?.message, details: e?.details }, null, 2); } catch { return String(e); } })();
      console.error('[runRaffleNow] failed', e);
      setSeedInfo({ code: e?.code || 'internal', message: e?.message || String(e), debug: edbg });
    } finally {
      setRaffleBusy(false);
    }
  }

  const totalTickets = entrants.reduce((s, e) => s + e.w, 0);

  async function grantTestTickets() {
    setGrantBusy(true);
    setGrantInfo(null);
    try {
      const fn = httpsCallable(getFunctions(undefined, 'us-central1'), 'grantTickets');
      const res: any = await fn({ amount: 3, mode: 'base' });
      const data = res?.data || {};
      console.log('[grantTickets] test response', data);
      const added = data.added ?? data.applied ?? data.ok ? 3 : 0;
      setGrantInfo(`grantTickets OK ‚Ä¢ +${added} Tickets (${data.day || 'n/a'})`);
      await loadEntrants();
    } catch (e: any) {
      console.error('[grantTickets] test failed', e);
      const msg = e?.message || e?.code || String(e);
      setGrantInfo(`grantTickets Fehler: ${msg}`);
    } finally {
      setGrantBusy(false);
    }
  }

  // Debug Info Text
  const [debugText, setDebugText] = useState<string>('');

  // Reference to shared base variable
  const serverNowBaseRef = useRef<number>(0);
  const perfBaseRef = useRef<number>(0);

  useEffect(() => {
    const updateDebugText = () => {
      try {
        const baseReady = serverNowBaseRef.current > 0 && perfBaseRef.current > 0;
        const now = baseReady ? (serverNowBaseRef.current + (performance.now() - perfBaseRef.current)) : Date.now();
        const parts = berlinPartsFromMs(now);
        const minutes = parts.hour * 60 + parts.minute;
        const freezeActive = (parts.hour === 20 && parts.minute < 15);
        const collectionDay = raffleCollectionDateIdFromMs(now);
        const drawDay = raffleDrawDateIdFromMs(now); 
        const displayDay = winnersDisplayDateIdFromMs(now);

        // Browser und System-Informationen sammeln
        const getBrowserInfo = () => {
          const ua = navigator.userAgent;
          let browser = 'Unbekannt';
          let os = 'Unbekannt';
          
          // Browser erkennen
          if (ua.includes('Chrome') && !ua.includes('Chromium') && !ua.includes('Edg')) browser = 'Chrome';
          else if (ua.includes('Firefox')) browser = 'Firefox';
          else if (ua.includes('Safari') && !ua.includes('Chrome')) browser = 'Safari';
          else if (ua.includes('Edg')) browser = 'Edge';
          else if (ua.includes('Opera') || ua.includes('OPR')) browser = 'Opera';
          
          // OS erkennen
          if (ua.includes('Windows')) os = 'Windows';
          else if (ua.includes('Mac')) os = 'macOS';
          else if (ua.includes('Linux')) os = 'Linux';
          else if (ua.includes('Android')) os = 'Android';
          else if (ua.includes('iPhone') || ua.includes('iPad')) os = 'iOS';
          
          return { browser, os };
        };

        const getLocationInfo = () => {
          // Zeitzone als Standort-Hinweis
          const timezone = Intl.DateTimeFormat().resolvedOptions().timeZone;
          const language = navigator.language;
          const languages = navigator.languages?.join(', ') || language;
          
          // Land aus Zeitzone ableiten (grober Hinweis)
          let probableCountry = 'Unbekannt';
          if (timezone.includes('Europe/Berlin') || timezone.includes('Europe/Vienna') || timezone.includes('Europe/Zurich')) {
            probableCountry = 'DACH-Region';
          } else if (timezone.includes('Europe/')) {
            probableCountry = 'Europa';
          } else if (timezone.includes('America/')) {
            probableCountry = 'Amerika';
          } else if (timezone.includes('Asia/')) {
            probableCountry = 'Asien';
          }
          
          return { timezone, language, languages, probableCountry };
        };

        const getDeviceInfo = () => {
          const screen = window.screen;
          const viewport = { width: window.innerWidth, height: window.innerHeight };
          const pixelRatio = window.devicePixelRatio || 1;
          const isMobile = /Android|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
          const isTablet = /iPad|Android(?!.*Mobile)/i.test(navigator.userAgent);
          
          return {
            screenRes: `${screen.width}x${screen.height}`,
            viewport: `${viewport.width}x${viewport.height}`,
            pixelRatio,
            deviceType: isMobile ? 'Mobile' : isTablet ? 'Tablet' : 'Desktop'
          };
        };

        const browserInfo = getBrowserInfo();
        const locationInfo = getLocationInfo();
        const deviceInfo = getDeviceInfo();

        const text = [
          '=== ZEIT & SPIEL INFO ===',
          `Berlin Zeit: ${String(parts.hour).padStart(2,'0')}:${String(parts.minute).padStart(2,'0')}`,
          `Collection Tag: ${collectionDay}`,
          `Draw Tag: ${drawDay}`,
          `Display Tag: ${displayDay}`,
          `20:00-20:15 ${freezeActive ? 'aktiv' : 'inaktiv'}`,
          `Tickets gesamt: ${totalTickets}`,
          `${minutes < (20*60+15) ? 'N√§chster Wechsel: 20:15' : 'N√§chster Wechsel: morgen 20:15'}`,
          '',
          '=== SPIELER SYSTEM INFO ===',
          `Browser: ${browserInfo.browser}`,
          `Betriebssystem: ${browserInfo.os}`,
          `Ger√§tetyp: ${deviceInfo.deviceType}`,
          `Bildschirm: ${deviceInfo.screenRes}`,
          `Viewport: ${deviceInfo.viewport}`,
          `Pixel Ratio: ${deviceInfo.pixelRatio}`,
          '',
          '=== STANDORT & SPRACHE ===',
          `Zeitzone: ${locationInfo.timezone}`,
          `Wahrscheinliches Land: ${locationInfo.probableCountry}`,
          `Hauptsprache: ${locationInfo.language}`,
          `Alle Sprachen: ${locationInfo.languages}`,
          '',
          '=== TECHNISCHE DETAILS ===',
          `User Agent: ${navigator.userAgent.substring(0, 100)}...`,
          `Online Status: ${navigator.onLine ? 'Online' : 'Offline'}`,
          `Cookie aktiviert: ${navigator.cookieEnabled ? 'Ja' : 'Nein'}`
        ].join('\n');
        setDebugText(text);
      } catch (e) {
        console.error('[debug] update failed', e);
      }
    };

    // Initial update
    updateDebugText();
    
    // Update every minute
    const interval = setInterval(updateDebugText, 60 * 1000);
    return () => clearInterval(interval);
  }, [totalTickets]);

  return (
    <div className="fixed inset-0 z-40 flex items-center justify-center">
      <div className="absolute inset-0 bg-black/80" onClick={onClose} />
      <div className="relative bg-white text-black rounded-2xl shadow-xl w-[min(96vw,900px)] max-h-[90vh] p-4 overflow-auto">
        <button
          onClick={onClose}
          className="absolute top-3 right-3 text-black/60 hover:text-black"
        >
          ‚úï
        </button>
        <div className="text-lg font-bold mb-2">Raffle Test-Terminal</div>

        <div className="grid grid-cols-1 md:grid-cols-3 gap-3 mb-3">
          <label className="text-sm">
            Datum (YYYY-MM-DD)
            <input
              value={dateId}
              onChange={(e) => setDateId(e.target.value)}
              className="w-full border px-2 py-1 rounded"
            />
          </label>
          <label className="text-sm">
            Seed
            <input
              value={seed}
              onChange={(e) => setSeed(e.target.value)}
              className="w-full border px-2 py-1 rounded"
            />
          </label>
          <div className="text-sm flex flex-col gap-2">
            <label className="flex items-center gap-2">
              <input
                type="checkbox"
                checked={forceRaffleWindow}
                onChange={(e) => onForceRaffleWindowChange(e.target.checked)}
                className="rounded border-gray-300"
              />
              <span>Simuliere 20:00‚Äì20:15 Countdown</span>
            </label>
            <label className="flex flex-col">
              <span>Prizes JSON</span>
              <textarea
                value={prizesText}
                onChange={(e) => setPrizesText(e.target.value)}
                className="w-full border px-2 py-1 rounded h-16 font-mono text-xs"
              />
            </label>
          </div>
        </div>

        <div className="flex flex-wrap gap-2 mb-3">
          {seedInfo && (
            <div className="mb-2 text-xs">
              <span className="font-semibold">Status:</span> [{seedInfo.code}] {seedInfo.message}
              {seedInfo.debug && (
                <details className="mt-1">
                  <summary className="cursor-pointer select-none">Debug</summary>
                  <pre className="mt-1 p-2 bg-black/5 rounded max-h-48 overflow-auto text-[10px] whitespace-pre-wrap break-words">
                    {seedInfo.debug}
                  </pre>
                </details>
              )}
            </div>
          )}
          {grantInfo && (
            <div className="mb-2 text-xs text-emerald-700">
              <span className="font-semibold">Tickets:</span> {grantInfo}
            </div>
          )}
          <button
            onClick={loadEntrants}
            className="px-3 py-1 rounded bg-black text-white disabled:opacity-50"
            disabled={loading}
          >
            Entries laden
          </button>
          <button
            onClick={runSim}
            className="px-3 py-1 rounded bg-black text-white"
            disabled={entrants.length === 0}
          >
            Ziehung simulieren
          </button>
          <button
            onClick={runCloudRaffle}
            className="px-3 py-1 rounded bg-black text-white disabled:opacity-50"
            disabled={raffleBusy || loading}
          >
            Ziehung starten (Cloud)
          </button>
          <button
            onClick={grantTestTickets}
            className="px-3 py-1 rounded bg-black text-white disabled:opacity-50"
            disabled={grantBusy}
          >
            +3 Tickets testen
          </button>
          {winners.length > 0 && (
            <button
              onClick={() => navigator.clipboard.writeText(JSON.stringify(winners))}
              className="px-3 py-1 rounded bg-black text-white"
            >
              Gewinner kopieren
            </button>
          )}
        </div>

        <div className="text-sm mb-2">
          Teilnehmer: <span className="tabular-nums">{entrants.length}</span> ‚Ä¢ Tickets gesamt:{' '}
          <span className="tabular-nums">{totalTickets}</span>
        </div>

        {entrants.length > 0 && (
          <div className="mb-3 overflow-auto max-h-48 border rounded">
            <table className="min-w-full text-xs">
              <thead>
                <tr>
                  <th className="text-left p-1">UID</th>
                  <th className="text-right p-1">Tickets</th>
                </tr>
              </thead>
              <tbody>
                {entrants.slice(0, 200).map((e, i) => (
                  <tr key={`${e.uid}-${i}`} className={i % 2 ? 'bg-black/5' : ''}>
                    <td className="p-1">{e.uid}</td>
                    <td className="p-1 text-right tabular-nums">{e.w}</td>
                  </tr>
                ))}
              </tbody>
            </table>
          </div>
        )}

        {winners.length > 0 && (
          <>
            <div className="text-sm font-semibold mb-1">Letzte Gewinner</div>
            <div className="mb-2 overflow-auto max-h-56 border rounded">
              <table className="min-w-full text-xs">
                <thead>
                  <tr>
                    <th className="text-left p-1">UID</th>
                    <th className="text-right p-1">Prize</th>
                  </tr>
                </thead>
                <tbody>
                  {winners.map((w, i) => (
                    <tr key={`${w.uid}-${i}`} className={i % 2 ? 'bg-black/5' : ''}>
                      <td className="p-1">{w.uid}</td>
                      <td className="p-1 text-right">{w.amount}‚Ç¨</td>
                    </tr>
                  ))}
                </tbody>
              </table>
            </div>
          </>
        )}

        {raffleInfo?.winners && (
          <>
            <div className="text-sm font-semibold mb-1">
              Cloud-Gewinner ({raffleInfo.dateId} ‚Ä¢ Level {raffleInfo.levelKey || '?'})
            </div>
            <div className="mb-2 overflow-auto max-h-56 border rounded">
              <table className="min-w-full text-xs">
                <thead>
                  <tr>
                    <th className="text-left p-1">Name</th>
                    <th className="text-right p-1">Prize</th>
                  </tr>
                </thead>
                <tbody>
                  {Object.keys(raffleInfo.winners)
                    .sort((a, b) => Number(a) - Number(b))
                    .map((k, i) => {
                      const r = (raffleInfo!.winners as any)[k];
                      return (
                        <tr key={k} className={i % 2 ? 'bg-black/5' : ''}>
                          <td className="p-1">{r?.name || '‚Äî'}</td>
                          <td className="p-1 text-right">{r?.prize || ''}</td>
                        </tr>
                      );
                    })}
                </tbody>
              </table>
            </div>
          </>
        )}

        {/* Debug Info Panel */}
        <pre className="mt-4 p-3 text-xs bg-black/5 rounded border border-black/10 font-mono whitespace-pre-wrap break-words">
          {debugText}
        </pre>

        <div className="mt-3 text-xs text-black/60">Simulation.</div>
      </div>
    </div>
  );
}
import { getAuth, onAuthStateChanged } from "firebase/auth";
import { getFunctions, httpsCallable } from "firebase/functions";
import { getDatabase, ref as dbRef, onValue } from "firebase/database";
import { AccountPanel } from "../profile/page";
import { useRouter } from "next/navigation";
import { getAuth as getAuthFull, deleteUser, reauthenticateWithPopup, GoogleAuthProvider } from "firebase/auth";

// One-shot confetti burst (Canvas overlay)
function ConfettiBurst({ onDone }: { onDone: () => void }) {
  const canvasRef = useRef<HTMLCanvasElement | null>(null);
  const onDoneRef = useRef(onDone);
  useEffect(() => { onDoneRef.current = onDone; }, [onDone]);
  useEffect(() => {
    const canvas = document.createElement('canvas');
    canvasRef.current = canvas;
    canvas.className = 'fixed inset-0 w-screen h-screen pointer-events-none z-[9999]';
    document.body.appendChild(canvas);
    const ctx = canvas.getContext('2d');
    let raf = 0;
    let running = true;

    function resize() {
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;
    }
    resize();
    window.addEventListener('resize', resize);

    const N = 220;
    const colors = ['#f59e0b','#10b981','#3b82f6','#ef4444','#a855f7','#f97316'];
    const particles = Array.from({ length: N }).map((_, i) => {
      // Centered around upward (-PI/2) with ¬±90¬∞ spread
      const angle = -Math.PI / 2 + (Math.random() - 0.5) * Math.PI; // [-135¬∞, -45¬∞]
      const speed = 5 + Math.random() * 6;
      const vx = Math.cos(angle) * speed;      // balanced left/right
      const vy = Math.sin(angle) * speed - 4;  // consistent upward kick
      return {
        x: canvas.width / 2 + (Math.random() - 0.5) * 40,
        y: canvas.height / 3,
        vx,
        vy,
        g: 0.18 + Math.random() * 0.08,
        size: 8 + Math.random() * 8,
        rot: Math.random() * Math.PI * 2,
        vr: (-0.3 + Math.random() * 0.6),
        life: 0,
        color: colors[i % colors.length],
      };
    });

    const t0 = performance.now();
    const duration = 4000; // ms

    function tick(t: number) {
      if (!ctx) return;
      const last = (tick as any).lt ?? t;
      const dt = t - last;
      (tick as any).lt = t;
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      for (const p of particles) {
        p.life += dt;
        p.vy += p.g;
        p.x += p.vx;
        p.y += p.vy;
        p.rot += p.vr;
        // simple drag
        p.vx *= 0.992;
        p.vy *= 0.992;
        ctx.save();
        ctx.translate(p.x, p.y);
        ctx.rotate(p.rot);
        ctx.fillStyle = p.color;
        ctx.fillRect(-p.size / 2, -p.size / 2, p.size, p.size * 0.7);
        // Add faint outline for better visibility
        ctx.strokeStyle = 'rgba(0,0,0,0.15)';
        ctx.lineWidth = 1;
        ctx.strokeRect(-p.size / 2, -p.size / 2, p.size, p.size * 0.7);
        ctx.restore();
      }
      if (running && t - t0 < duration) {
        raf = requestAnimationFrame(tick);
      } else {
        cleanup();
      }
    }

    function cleanup() {
      if (!running) return;
      running = false;
      cancelAnimationFrame(raf);
      window.removeEventListener('resize', resize);
      if (canvas.parentNode) canvas.parentNode.removeChild(canvas);
    }

    raf = requestAnimationFrame(tick);
    const timeout = setTimeout(() => { cleanup(); onDoneRef.current?.(); }, duration + 200);
    return () => { clearTimeout(timeout); cleanup(); };
  }, []);

  return null;
}

// Stylized preview card for the Countdown minigame (used when no image is available)
function CountdownPreviewCard({ title, timeLabel }: { title: string; timeLabel: string }) {
  // Yesterday winners from Firestore: config/winners[YYYY-MM-DD]
  type WinnerRow = { name: string; prize: string; time?: string };
  const [winners, setWinners] = useState<WinnerRow[]>([]);

  useEffect(() => {
    let cancelled = false;
    const dayRef = { current: '' };

    const load = async (dayId: string) => {
      try {
        const fs = getFirestore();
        const snap = await getDoc(doc(fs, 'config', 'winners'));
        if (cancelled) return;
        const data: any = snap.exists() ? snap.data() : null;
        const rows: any[] = Array.isArray(data?.[dayId]) ? data[dayId] : Array.isArray(data?.days?.[dayId]) ? data.days[dayId] : [];
        const normalized: WinnerRow[] = rows
          .map((r: any) => ({ name: String(r?.name || r?.n || '‚Äî'), prize: String(r?.prize || r?.p || ''), time: r?.time ? String(r.time) : undefined }))
          .filter((r: WinnerRow) => r.name && r.prize);
        setWinners(normalized);
      } catch (e) {
        if (!cancelled) {
          setWinners([]);
          console.warn('[winners] load failed', e);
        }
      }
    };

    const refresh = () => {
      const baseReady = serverNowBaseRef.current > 0 && perfBaseRef.current > 0;
      const now = baseReady ? (serverNowBaseRef.current + (performance.now() - perfBaseRef.current)) : Date.now();
      const dayId = winnersDisplayDateIdFromMs(now);
      if (dayId === dayRef.current) return;
      dayRef.current = dayId;
      load(dayId);
    };

    refresh();
    const interval = setInterval(refresh, 60 * 1000);
    return () => {
      cancelled = true;
      clearInterval(interval);
    };
  }, []);
  return (
    <div className="relative w-full h-full rounded-[20px] overflow-hidden">
      {/* glossy background */}
      <div className="absolute inset-0">
        <div className="absolute inset-0 bg-gradient-to-br from-purple-600 via-fuchsia-600 to-rose-500" />
        {/* radial glow blobs */}
        <div className="absolute -top-20 -left-16 w-64 h-64 rounded-full bg-white/15 blur-3xl" />
        <div className="absolute -bottom-24 -right-16 w-72 h-72 rounded-full bg-white/10 blur-3xl" />
        {/* diagonal stripes */}
        <div className="absolute inset-0 opacity-[0.08] bg-[length:28px_28px] bg-[linear-gradient(45deg,white_2px,transparent_2px)]" />
      </div>

      {/* content */}
      <div className="relative z-10 h-full flex items-center justify-between px-6">
        {/* left: icon + title */}
        <div className="flex items-center gap-4">
          <div className="shrink-0 w-16 h-16 rounded-2xl bg-white/20 backdrop-blur-sm flex items-center justify-center text-white">
            {/* timer icon */}
            <svg className="w-10 h-10" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" aria-hidden>
              <circle cx="12" cy="13" r="8" />
              <path d="M12 13V9" />
              <path d="M9 2h6" />
            </svg>
          </div>
          <div className="text-white">
            <div className="text-2xl font-extrabold drop-shadow-sm leading-none">{title}</div>
            <div className="mt-1 text-white/80 text-sm">Reagiere vor Ablauf des Countdowns</div>
          </div>
        </div>

        {/* right: timer chip + CTA */}
        <div className="flex flex-col items-end gap-2">
          <div className="px-3 py-1 rounded-full bg-white/90 text-black text-sm font-semibold shadow">{timeLabel}</div>
          <div className="px-3 py-1 rounded-full bg-black/40 text-white text-xs font-semibold border border-white/20 animate-cta-shine">Schnell spielen</div>
        </div>
      </div>

      {/* corner badge */}
      <div className="absolute top-3 left-3 px-2 py-1 rounded-full bg-black/40 text-white text-[11px] font-semibold border border-white/15">NEU</div>
    </div>
  );
}


// 3D tilt Steam-style gift card sprite for prize pool
function GiftCard3D({ title, img, children }: { title?: string; img?: string; children?: React.ReactNode }) {
  const wrapRef = useRef<HTMLDivElement | null>(null);
  const handle = (e: React.MouseEvent<HTMLDivElement>) => {
    const el = wrapRef.current; if (!el) return;
    const r = el.getBoundingClientRect();
    const x = (e.clientX - r.left) / r.width;   // 0..1
    const y = (e.clientY - r.top) / r.height;  // 0..1
    const rx = (0.5 - y) * 32; // stronger tilt up/down (doubled)
    const ry = (x - 0.5) * 40; // stronger tilt left/right (doubled)
    const tx = (x - 0.5) * 36; // stronger parallax x (doubled)
    const ty = (0.5 - y) * 36; // stronger parallax y (doubled)
    el.style.setProperty('--rx', rx.toFixed(2));
    el.style.setProperty('--ry', ry.toFixed(2));
    el.style.setProperty('--mx', (x * 100).toFixed(1) + '%');
    el.style.setProperty('--my', (y * 100).toFixed(1) + '%');
    el.style.setProperty('--tx', tx.toFixed(2) + 'px');
    el.style.setProperty('--ty', ty.toFixed(2) + 'px');
  };
  const leave = () => {
    const el = wrapRef.current; if (!el) return;
    el.style.setProperty('--rx', '0');
    el.style.setProperty('--ry', '0');
    el.style.setProperty('--tx', '0px');
    el.style.setProperty('--ty', '0px');
  };
  return (
    <div
      ref={wrapRef}
      onMouseMove={handle}
      onMouseLeave={leave}
      className="holo group relative w-full h-full [perspective:1200px] select-none"
    >
      <div className="card relative w-full h-full rounded-2xl overflow-hidden border border-white/10 bg-black/30 backdrop-blur-[2px]">
        {/* Base gradient similar to minigame when no image is supplied */}
        {img ? (
          <img src={img} alt={title || 'Preis'} className="absolute inset-0 w-full h-full object-cover" />
        ) : (
          <div className="absolute inset-0 bg-gradient-to-br from-neutral-200 via-white to-neutral-100" />
        )}
        {/* Animated neon border replaced with static border */}
        <div
          className="absolute inset-0 rounded-2xl pointer-events-none border-2 border-black"
        />
        {/* Children rendered on top */}
        {children ? <div className="absolute inset-0 z-20 pointer-events-none">{children}</div> : null}
        {/* No inner content; sprite is the card itself */}
      </div>
    </div>
  );
}

// Interactive Neon Hologram card for the minigame
function NeonHoloCard({ title, subtitle, timeLabel, img, onImgLoad, onImgError, onStart, uid, onShowAccount }: { title: string; subtitle: string; timeLabel: string; img?: string | null; onImgLoad?: () => void; onImgError?: () => void; onStart?: () => void; uid?: string | null; onShowAccount?: () => void; }) {
  const wrapRef = useRef<HTMLDivElement | null>(null);
  const handle = (e: React.MouseEvent<HTMLDivElement>) => {
    const el = wrapRef.current; if (!el) return;
    const r = el.getBoundingClientRect();
    const x = (e.clientX - r.left) / r.width;   // 0..1
    const y = (e.clientY - r.top) / r.height;  // 0..1
    const rx = (0.5 - y) * 16; // stronger tilt up/down
    const ry = (x - 0.5) * 20; // stronger tilt left/right
    el.style.setProperty('--rx', rx.toFixed(2));
    el.style.setProperty('--ry', ry.toFixed(2));
    el.style.setProperty('--mx', (x * 100).toFixed(1) + '%');
    el.style.setProperty('--my', (y * 100).toFixed(1) + '%');
  };
  const leave = () => {
    const el = wrapRef.current; if (!el) return;
    el.style.setProperty('--rx', '0');
    el.style.setProperty('--ry', '0');
  };
  return (
    <div ref={wrapRef} onMouseMove={handle} onMouseLeave={leave}
      className="holo group relative w-full h-full [perspective:1200px] select-none">
      {/* 3D card */}
      <button
        type="button"
        aria-label={uid ? "Spiel starten" : "Einloggen zum Spielen"}
        onClick={() => {
          console.log('[MINIGAME CLICK] Button clicked, uid:', uid, 'title:', title);
          
          // Check if user is logged in
          if (!uid) {
            console.log('[MINIGAME CLICK] User not logged in, showing account panel');
            // User not logged in - show account panel instead
            try { onShowAccount?.(); } catch {}
            return;
          }
          
          console.log('[MINIGAME CLICK] User logged in, proceeding with game');
          // User is logged in - proceed with game
          try { onStart?.(); } catch {}
          try { 
            console.log('[MINIGAME CLICK] Calling markDropStart...');
            markDropStart(); 
          } catch (e) {
            console.error('[MINIGAME CLICK] markDropStart failed:', e);
          }
          // Dynamic navigation based on game title/slug
          try {
            const gameRoute = title && title !== 'Minigame' ? `/games/${title}` : '/games/tap-rush';
            console.log('[NAVIGATION] Attempting navigation to:', gameRoute);
            window.location.href = gameRoute;
            console.log('[NAVIGATION] Navigation command sent successfully');
          } catch (e) {
            console.error('[NAVIGATION] Primary navigation failed:', e);
            // Fallback to tap-rush if navigation fails
            try {
              console.log('[NAVIGATION] Trying fallback to /games/tap-rush');
              window.location.href = '/games/tap-rush';
            } catch (e2) {
              console.error('[NAVIGATION] Fallback navigation also failed:', e2);
            }
          }
        }}
        className="card relative w-[120%] -ml-[10%] h-full rounded-2xl overflow-hidden border border-white/10 bg-black/30 backdrop-blur-[2px] shadow-[0_10px_50px_rgba(0,0,0,0.45)]"
      >
        {/* Background image only */}
        {img ? (
          <img
            src={img}
            alt="Minigame"
            className="absolute inset-0 w-full h-full object-cover"
            onLoad={onImgLoad}
            onError={onImgError}
          />
        ) : (
          <div className="absolute inset-0 bg-gradient-to-br from-fuchsia-600 via-purple-600 to-rose-500" />
        )}

        {/* Animated neon border replaced with static border */}
        <div
          className="absolute inset-0 rounded-2xl pointer-events-none border-2 border-black"
        />

        {/* Schwarzer Balken mit Spielname am unteren Rand */}
        <div className="absolute bottom-0 left-0 right-0 bg-black text-white px-3 py-2 font-bold text-sm tracking-wide rounded-b-2xl flex items-center">
          <span>{title.toUpperCase()}</span>
          <span className="animate-pulse text-xs opacity-80 absolute left-1/2 transform -translate-x-1/2 flex items-center gap-1">
            PRESS TO PLAY
            <img 
              src="/play-icon.svg" 
              alt="Play" 
              className="w-3 h-3 animate-pulse opacity-80" 
            />
          </span>
        </div>

        {/* Countdown pill only */}
        <div className="absolute bottom-1 right-2 z-20 px-3 py-1 rounded-full bg-white text-black text-xs font-semibold shadow-sm border border-black/10 tabular-nums">
          {timeLabel}
        </div>
      </button>
    </div>
  );
}


export default function DropPage() {


  const [isHydrated, setIsHydrated] = useState(false);
  useEffect(() => {
    setIsHydrated(true);
  }, []);

  // Auto-Refresh um 20:15 Uhr Berlin Zeit
  useEffect(() => {
    let hasRefreshed = false; // Verhindert mehrfache Refreshs
    
    const checkRefreshTime = () => {
      if (hasRefreshed) return;
      
      const now = new Date();
      // Korrekte Berlin Zeit mit Intl.DateTimeFormat
      const berlinFormatter = new Intl.DateTimeFormat('en-CA', {
        timeZone: 'Europe/Berlin',
        hour: '2-digit',
        minute: '2-digit',
        second: '2-digit',
        hour12: false
      });
      
      const berlinTime = berlinFormatter.format(now);
      const [hours, minutes, seconds] = berlinTime.split(':').map(Number);
      
      console.log(`[auto-refresh] Berlin Zeit: ${hours}:${minutes}:${seconds}`);
      
      // Wenn es 20:15:xx ist (beliebige Sekunde)
      if (hours === 20 && minutes === 15) {
        console.log('[auto-refresh] üîÑ Auto-Refresh um 20:15 Uhr ausgel√∂st');
        hasRefreshed = true;
        window.location.reload();
      }
    };

    // Sofort pr√ºfen beim Load
    checkRefreshTime();
    
    // Pr√ºfe alle 10 Sekunden f√ºr bessere Genauigkeit
    const interval = setInterval(checkRefreshTime, 10000);
    
    // Cleanup bei unmount
    return () => clearInterval(interval);
  }, []);

  // Capture Referral Code from URL
  useEffect(() => {
    try {
      const url = new URL(window.location.href);
      const refCode = url.searchParams.get('ref');
      
      console.log('[referral-debug] Current URL:', window.location.href);
      console.log('[referral-debug] Extracted ref code:', refCode);
      console.log('[referral-debug] Code length:', refCode?.length);
      
      if (refCode && typeof refCode === 'string' && refCode.length === 6) {
        // Speichere Referral Code in sessionStorage f√ºr sp√§tere Verwendung
        const referralData = {
          code: refCode,
          timestamp: Date.now(),
          url: window.location.href
        };
        
        sessionStorage.setItem('pendingReferral', JSON.stringify(referralData));
        console.log('[referral-debug] ‚úÖ Stored referral data:', referralData);
        
        // Optional: URL bereinigen ohne Page Reload
        if (window.history?.replaceState) {
          const cleanUrl = new URL(window.location.href);
          cleanUrl.searchParams.delete('ref');
          window.history.replaceState({}, '', cleanUrl.toString());
          console.log('[referral-debug] ‚úÖ Cleaned URL to:', cleanUrl.toString());
        }
      } else {
        console.log('[referral-debug] ‚ùå Invalid or missing ref code');
      }
      
      // Check if there's already stored referral data
      const existing = sessionStorage.getItem('pendingReferral');
      if (existing) {
        console.log('[referral-debug] üìã Existing referral data found:', JSON.parse(existing));
      } else {
        console.log('[referral-debug] üìã No existing referral data');
      }
      
    } catch (error) {
      console.error('[referral-debug] ‚ùå Failed to capture referral code:', error);
    }
  }, []);

  // State for minigame slug/title
  const [gameSlug, setGameSlug] = useState<string | null>(null);
  useEffect(() => {
    try { sessionStorage.setItem('drop.present', String(Date.now())); } catch {}
    return () => { try { sessionStorage.removeItem('drop.present'); } catch {} };
  }, []);
  const router = useRouter();
  const [deletingAcc, setDeletingAcc] = useState(false);

  // Winners: gestern aus Firestore (config/winners[YYYY-MM-DD] oder days[...])
  type WinnersRow = { name: string; prize: string; time?: string; _source?: 'days' | 'top' | 'array'; _day?: string };
  const [winners, setWinners] = useState<WinnersRow[]>([]);
  const [winnersDateLabel, setWinnersDateLabel] = useState<string>("");
  const [latestWinner, setLatestWinner] = useState<WinnersRow | null>(null);
  const [latestWinnerSource, setLatestWinnerSource] = useState<'days' | 'top' | 'array' | undefined>(undefined);
  const [latestWinnerDay,   setLatestWinnerDay]   = useState<string | undefined>(undefined);
  const [winnersDebugText,  setWinnersDebugText]  = useState<string>("");

  useEffect(() => {
    const fs = getFirestore();
    let cancelled = false;

    const loadWinners = async (_dayId?: string) => {
      try {
        const snap = await getDoc(doc(fs, 'config', 'winners'));
        if (cancelled) return;
        const data: any = snap.exists() ? snap.data() : null;

        // === SIMPLE SOURCE: config/winners[YYYY-MM-DD] (map-like: "0","1",...) ===
        // Determine Anzeige-Tag (20:15-Regel)
        const baseReady = serverNowBaseRef.current > 0 && perfBaseRef.current > 0;
        const now = baseReady ? (serverNowBaseRef.current + (performance.now() - perfBaseRef.current)) : Date.now();
        const dayId = winnersDisplayDateIdFromMs(now);
        
        // DEBUG: Check what dates are available in winners data
        console.log('[loadWinners] Searching for dayId:', dayId);
        console.log('[loadWinners] Available dates in data:', data ? Object.keys(data) : 'no data');

        // Coerce map-like object to ordered array by numeric keys
        const asArr = (node: any): any[] => {
          if (!node || typeof node !== 'object') return [];
          const numKeys = Object.keys(node).filter(k => /^\d+$/.test(k)).map(k => Number(k)).sort((a,b)=>a-b);
          return numKeys.map(i => (node as any)[String(i)]);
        };

        const rawDay = (data || {})[dayId];
        const rowsRaw: any[] = Array.isArray(rawDay) ? rawDay : asArr(rawDay);

        type W = WinnersRow;
        const all: W[] = rowsRaw
          .map((r: any) => ({
            name: String(r?.name ?? r?.n ?? '').trim(),
            prize: String(r?.prize ?? r?.p ?? '').trim(),
            time: r?.time ? String(r.time) : undefined,
            _source: 'top',
            _day: dayId,
          }))
          .filter((r: W) => r.name.length > 0 && r.prize.length > 0);

        // Pick latest (by time if vorhanden, sonst letzte Zeile)
        let latest: W | null = null;
        const parseScore = (t?: string, idx: number) => {
          if (!t) return idx;
          const asDate = Date.parse(t);
          if (!Number.isNaN(asDate)) return asDate;
          const m = /^(\d{2}):(\d{2})(?::(\d{2}))?$/.exec(t);
          if (m) { const h=+m[1]||0, mi=+m[2]||0, s=+(m[3]||'0')||0; return h*3600+mi*60+s+idx/1000; }
          return idx;
        };
        all.forEach((r, i) => { const s = parseScore(r.time, i); if (!latest || s >= parseScore(latest.time, i-1)) latest = r; });

        // UI: zeige alle Gewinner dieses Anzeige-Tages
        setWinners(all);
        setLatestWinner(latest);
        setLatestWinnerSource('top');
        setLatestWinnerDay(dayId);
  setWinnersDateLabel('Letzte Gewinner:');

        // Debug-Overlay-Text aktualisieren
        try {
          const parts = berlinPartsFromMs(now);
          const minutes = parts.hour * 60 + parts.minute;
          const freezeActive = (parts.hour === 20 && parts.minute < 15);
          const where = `config/winners[${dayId}]`;
          const hh = String(parts.hour).padStart(2, '0');
          const mm = String(parts.minute).padStart(2, '0');
          const rule = `Regel: 20:00‚Äì20:15 keine Aktualisierung; Anzeige-Tag bis 20:14 = gestern, ab 20:15 = heute.`;
          const nextSwitch = minutes < (20*60+15) ? `N√§chster Wechsel 20:15` : `N√§chster Wechsel morgen 20:15`;
          setWinnersDebugText(`Quelle: ${where} ‚Ä¢ Jetzt (Berlin): ${hh}:${mm} ‚Ä¢ Anzeige-Tag: ${dayId} ‚Ä¢ Freeze aktiv: ${freezeActive ? 'ja' : 'nein'} ‚Ä¢ ${nextSwitch}. ${rule}`);
        } catch {}
      } catch (e) {
        if (cancelled) return;
        console.warn('[winners] load failed', e);
        setWinners([]);
        setLatestWinner(null);
  setWinnersDateLabel('Letzte Gewinner:');
      }
    };

    const refresh = () => {
      // Lade immer die Winners - das Freeze nur f√ºr die Tag-Berechnung (in winnersDisplayDateIdFromMs)
      // Die Winners vom vorherigen Tag sollen weiterhin angezeigt werden
      loadWinners();
    };

    refresh();
    const interval = setInterval(refresh, 60 * 1000);
    return () => {
      cancelled = true;
      clearInterval(interval);
    };
  }, []);

  // Keep the overlay text in sync
  useEffect(() => {
    const el = document.getElementById('winners-debug-overlay');
    if (el) el.textContent = winnersDebugText || '';
  }, [winnersDebugText]);

  // Also refresh the clock-based parts each minute
  useEffect(() => {
    const tick = () => {
      try {
        const baseReady = serverNowBaseRef.current > 0 && perfBaseRef.current > 0;
        const now = baseReady ? (serverNowBaseRef.current + (performance.now() - perfBaseRef.current)) : Date.now();
        const parts = berlinPartsFromMs(now);
        const minutes = parts.hour * 60 + parts.minute;
        const freezeActive = (parts.hour === 20 && parts.minute < 15);
        const displayDay = winnersDisplayDateIdFromMs(now);
        const where = latestWinnerSource === 'days' ? `config/winners.days[${latestWinnerDay || '‚Äî'}]`
                    : latestWinnerSource === 'top'  ? `config/winners[${latestWinnerDay || '‚Äî'}]`
                    : latestWinnerSource === 'array'? `config/winners (Array)`
                    : `config/winners (unbekannt)`;
        const hh = String(parts.hour).padStart(2, '0');
        const mm = String(parts.minute).padStart(2, '0');
        const rule = `Regel: 20:00‚Äì20:15 keine Aktualisierung; Anzeige-Tag bis 20:14 = gestern, ab 20:15 = heute.`;
        const nextSwitch = minutes < (20*60+15) ? `N√§chster Wechsel 20:15` : `N√§chster Wechsel morgen 20:15`;
        setWinnersDebugText(`Quelle: ${where} ‚Ä¢ Jetzt (Berlin): ${hh}:${mm} ‚Ä¢ Anzeige-Tag: ${displayDay} ‚Ä¢ Freeze aktiv: ${freezeActive ? 'ja' : 'nein'} ‚Ä¢ ${nextSwitch}. ${rule}`);
      } catch { /* noop */ }
    };
    const iv = setInterval(tick, 60 * 1000);
    tick();
    return () => clearInterval(iv);
  }, [latestWinnerSource, latestWinnerDay]);

  async function handleDeleteAccount() {
    const auth = getAuthFull();
    const u = auth.currentUser;
    if (!u) { alert('Nicht eingeloggt'); return; }
    if (!confirm('Konto endg√ºltig l√∂schen? Dies kann nicht r√ºckg√§ngig gemacht werden.')) return;
    setDeletingAcc(true);
    try {
      try {
        await deleteUser(u);
      } catch (e: any) {
        if (e?.code === 'auth/requires-recent-login') {
          await reauthenticateWithPopup(u, new GoogleAuthProvider());
          await deleteUser(u);
        } else {
          throw e;
        }
      }
      router.push('/');
    } catch (err) {
      console.error('Account l√∂schen fehlgeschlagen', err);
      alert('L√∂schen fehlgeschlagen.');
    } finally {
      setDeletingAcc(false);
    }
  }
  const [authReady, setAuthReady] = useState(false);
  const [mustComplete, setMustComplete] = useState(false);
  const [authUser, setAuthUser] = useState<ReturnType<typeof getAuth>["currentUser"] | null>(null);
  const [profilePhoto, setProfilePhoto] = useState<string | null>(null);
  const [showTest, setShowTest] = useState(false);
  const [forceRaffleWindow, setForceRaffleWindow] = useState(false);
  const [testEnabled, setTestEnabled] = useState(false);

  useEffect(() => {
    try {
      const url = new URL(window.location.href);
      const enable = url.searchParams.get('test') === '1' || url.hostname === 'localhost';
      setTestEnabled(!!enable);
    } catch {}
  }, []);

  useEffect(() => {
    const auth = getAuth();
    const unsub = onAuthStateChanged(auth, async (u) => {
      setAuthUser(u);
      setProfilePhoto(withAvatarCache(u?.photoURL || null));
      if (!u) {
        // Kein gestarteter Account ‚Üí nicht automatisch √∂ffnen
        setMustComplete(false);
        setAuthReady(true);
        setProfilePhoto(null);
        setShowAccount(false);
        return;
      }
      if (!u.emailVerified) {
        // Account begonnen, aber nicht verifiziert ‚Üí automatisch √∂ffnen
        setMustComplete(true);
        setAuthReady(true);
        closeAllModals();
        setShowAccount(true);
        return;
      }
      try {
        const fs = getFirestore();
        const snap = await getDoc(doc(fs, "users", u.uid));
        const completed = !!(snap.exists() && (snap.data() as any)?.profileCompleted === true) && !!u.displayName && !!u.photoURL;
        setMustComplete(!completed);
        if (completed) {
          setShowAccount(false);
        } else {
          closeAllModals();
          setShowAccount(true);
        }
      } catch {
        // Nutzer existiert, aber Profil nicht lesbar ‚Üí als unvollst√§ndig behandeln
        setMustComplete(true);
        closeAllModals();
        setShowAccount(true);
      } finally {
        setAuthReady(true);
      }
    });
    return () => unsub();
  }, []);

  const [url, setUrl] = useState<string | null>(null);
  const [gameUrl, setGameUrl] = useState<string | null>(null);
  const [shadowUrl, setShadowUrl] = useState<string | null>(null);
  const [error, setError] = useState<string | null>(null);
  const [offset, setOffset] = useState({ x: 0, y: 0 });
  const [nextAtMs, setNextAtMs] = useState<number | null>(null);
  const [remaining, setRemaining] = useState<string>("");
  const [uid, setUid] = useState<string | null>(null);
  const [coins, setCoins] = useState<number>(0);
  const [ticketsToday, setTicketsToday] = useState<number>(0);
  const MIN_TICKETS_FOR_RAFFLE = 50;
  const ticketsTodaySafe = Math.max(0, ticketsToday || 0);
  // Global tickets total (today) for dynamic prize scaling
  const [ticketsTotalToday, setTicketsTotalToday] = useState<number>(0);
  const totalPoolTickets = Math.max(0, ticketsTotalToday || 0);
  const [poolLevel, setPoolLevel] = useState<number>(0);
  // Prize pool modal state (declare early so hooks below can reference showPool)
  type PrizeItem = { title?: string; image?: string; qty?: number };
  type PrizeLevel = { levelIndex: number; ticketsNeeded?: number; items?: PrizeItem[]; totalRewards?: number }
  const [showPool, setShowPool] = useState(false);
  const [poolItems, setPoolItems] = useState<PrizeItem[]>([]);
  const [prizeLevels, setPrizeLevels] = useState<PrizeLevel[] | null>(null);
  const [levelTotals, setLevelTotals] = useState<number[] | null>(null);
  const [totalRewards, setTotalRewards] = useState<number>(0);
  const [poolResolved, setPoolResolved] = useState<({ title?: string; qty?: number; url: string })[]>([]);


  const findLevelArrayIndex = (levelsList: PrizeLevel[] | null, target: number | null | undefined) => {
    if (!levelsList || levelsList.length === 0) return -1;
    if (target == null) return 0;
    let bestLowerIndex = -1;
    let bestLowerDiff = Number.POSITIVE_INFINITY;
    let bestHigherIndex = -1;
    let bestHigherDiff = Number.POSITIVE_INFINITY;
    for (let i = 0; i < levelsList.length; i++) {
      const candidate = levelsList[i];
      const idx = candidate.levelIndex;
      if (idx === target) return i;
      if (idx < target) {
        const diff = target - idx;
        if (diff < bestLowerDiff) {
          bestLowerDiff = diff;
          bestLowerIndex = i;
        }
      } else if (idx > target) {
        const diff = idx - target;
        if (diff < bestHigherDiff) {
          bestHigherDiff = diff;
          bestHigherIndex = i;
        }
      }
    }
    if (bestLowerIndex !== -1) return bestLowerIndex;
    if (bestHigherIndex !== -1) return bestHigherIndex;
    return 0;
  };

  const numberFormatter = useMemo(() => new Intl.NumberFormat('de-DE'), []);
  const ticketsBadgeText = useMemo(() => {
    return `${numberFormatter.format(ticketsTodaySafe)}/${numberFormatter.format(MIN_TICKETS_FOR_RAFFLE)}`;
  }, [numberFormatter, ticketsTodaySafe, MIN_TICKETS_FOR_RAFFLE]);

  const thresholdList = useMemo(() => {
    if (!prizeLevels || prizeLevels.length === 0) {
      return [] as Array<{ levelIndex: number; start: number; end: number; required: number }>;
    }
    const sorted = [...prizeLevels].sort((a, b) => a.levelIndex - b.levelIndex);
    let cumulative = 0;
    return sorted.map((lv) => {
      const raw = Number(lv.ticketsNeeded);
      const increment = Number.isFinite(raw) && raw > 0 ? Math.floor(raw) : 100;
      const required = Math.max(1, increment);
      const start = cumulative;
      const end = start + required;
      cumulative = end;
      return { levelIndex: lv.levelIndex, start, end, required };
    });
  }, [prizeLevels]);

  const poolProgress = useMemo(() => {
    if (thresholdList.length === 0) {
      const baseLevel = Math.floor(totalPoolTickets / 100);
      const baseThreshold = baseLevel * 100;
      const earnedRaw = Math.max(0, totalPoolTickets - baseThreshold);
      const required = 100;
      const earnedClamped = Math.max(0, Math.min(required, earnedRaw));
      const pct = Math.max(0, Math.min(100, Math.round((earnedClamped / required) * 100)));
      return {
        levelIndex: baseLevel,
        baseThreshold,
        nextThreshold: baseThreshold + required,
        earnedInLevel: earnedClamped,
        requiredForNext: required,
        pct,
        isMax: false,
        total: totalPoolTickets,
      };
    }

    let current = thresholdList[0];
    let next: typeof current | null = thresholdList.length > 1 ? thresholdList[1] : null;
    for (let i = 0; i < thresholdList.length; i++) {
      const entry = thresholdList[i];
      const nextEntry = thresholdList[i + 1] ?? null;
      if (totalPoolTickets >= entry.end && nextEntry) {
        current = nextEntry;
        next = thresholdList[i + 2] ?? null;
        continue;
      }
      current = entry;
      next = nextEntry;
      break;
    }

    const start = current.start;
    const required = Math.max(1, current.required);
    const end = current.end;
    const earnedRaw = Math.max(0, totalPoolTickets - start);
    const earnedClamped = Math.max(0, Math.min(required, earnedRaw));
    const pct = Math.max(0, Math.min(100, Math.round((earnedClamped / required) * 100)));

    if (!next && totalPoolTickets >= end) {
      return {
        levelIndex: current.levelIndex,
        baseThreshold: start,
        nextThreshold: null,
        earnedInLevel: earnedRaw,
        requiredForNext: null,
        pct: 100,
        isMax: true,
        total: totalPoolTickets,
      };
    }

    return {
      levelIndex: current.levelIndex,
      baseThreshold: start,
      nextThreshold: end,
      earnedInLevel: earnedClamped,
      requiredForNext: required,
      pct,
      isMax: false,
      total: totalPoolTickets,
    };
  }, [thresholdList, totalPoolTickets]);

  const effectivePoolLevel = Math.max(0, Math.max(poolLevel ?? 0, poolProgress.levelIndex ?? 0));
  const poolProgressLabel = poolProgress.requiredForNext != null
    ? `${numberFormatter.format(Math.max(0, Math.floor(poolProgress.earnedInLevel)))}/${numberFormatter.format(Math.max(0, Math.floor(poolProgress.requiredForNext)))}`
    : `${numberFormatter.format(Math.max(0, Math.floor(poolProgress.total)))}`;
  const poolProgressSuffix = poolProgress.requiredForNext != null ? 'Tickets' : 'Tickets gesamt';
  const poolProgressIsMax = poolProgress.requiredForNext == null;
  // --- Loading overlay: shown until Firebase data is ready on first load ---
  const [loading, setLoading] = useState(true);
  const [initialLoadDone, setInitialLoadDone] = useState(false);
  const [prizePoolLoaded, setPrizePoolLoaded] = useState(false);
  const [poolLevelServerLoaded, setPoolLevelServerLoaded] = useState(false);
  // Listen to aggregated tickets count for the Berlin day in metrics_daily/{YYYY-MM-DD}
  useEffect(() => {
    const fs = getFirestore();
    let unsub: (() => void) | null = null;
    let currentDayId: string | null = null;

    function resubscribe() {
      const baseReady = serverNowBaseRef.current > 0 && perfBaseRef.current > 0;
      const serverNow = baseReady ? (serverNowBaseRef.current + (performance.now() - perfBaseRef.current)) : Date.now();
      const dayId = raffleCollectionDateIdFromMs(serverNow);
      if (dayId === currentDayId) {
        return; // still same aggregation window; keep existing listener
      }
      currentDayId = dayId;
      if (unsub) { unsub(); unsub = null; }
      unsub = onSnapshot(
        doc(fs, 'metrics_daily', dayId),
        { includeMetadataChanges: true },
        (snap) => {
          const data: any = snap.exists() ? snap.data() : null;
          const v = data?.ticketsTodayTotal;
          setTicketsTotalToday(typeof v === 'number' ? v : 0);
          const lvl = data?.poolLevel;
          setPoolLevel(typeof lvl === 'number' ? lvl : 0);
          if (!snap.metadata.fromCache) setPoolLevelServerLoaded(true);
        },
        () => setTicketsTotalToday(0)
      );
      // Force a server read once to bypass cache and get the latest level immediately
      getDoc(doc(fs, 'metrics_daily', dayId)).then((snap) => {
        const data: any = snap.exists() ? snap.data() : null;
        const v = data?.ticketsTodayTotal;
        setTicketsTotalToday(typeof v === 'number' ? v : 0);
        const lvl = data?.poolLevel;
        setPoolLevel(typeof lvl === 'number' ? lvl : 0);
        setPoolLevelServerLoaded(true);
      }).catch(() => {});
      setTicketsTotalToday(0);
      setPoolLevel(0);
    }

    resubscribe();
    const iv = setInterval(resubscribe, 60 * 1000);
    return () => { if (unsub) unsub(); clearInterval(iv); };
  }, []);

  // When showPool is opened, fetch latest ticketsTotalToday from server immediately
  useEffect(() => {
    if (!showPool) return;
    const fs = getFirestore();
    const baseReady = serverNowBaseRef.current > 0 && perfBaseRef.current > 0;
    const serverNow = baseReady ? (serverNowBaseRef.current + (performance.now() - perfBaseRef.current)) : Date.now();
    const dayId = raffleCollectionDateIdFromMs(serverNow);
    getDoc(doc(fs, 'metrics_daily', dayId)).then((snap) => {
      const data: any = snap.exists() ? snap.data() : null;
      const v = data?.ticketsTodayTotal;
      setTicketsTotalToday(typeof v === 'number' ? v : 0);
      const lvl = data?.poolLevel;
      setPoolLevel(typeof lvl === 'number' ? lvl : 0);
      setPoolLevelServerLoaded(true);
    }).catch(() => {});
  }, [showPool]);
  const [until20, setUntil20] = useState<string>("");
  function getDefaultSmallTicker() {
    // Single default message ‚Äî do not repeat here
    return 'Platzhalter ‚Ä¢ News ‚Ä¢ Update';
  }
  const [smallTicker, setSmallTicker] = useState<string>(getDefaultSmallTicker());
  const smallTickerContainerRef = useRef<HTMLDivElement | null>(null);
  const smallTickerSpanRef = useRef<HTMLSpanElement | null>(null);

  // scroll container and footer refs to control header visibility on last screen
  const scrollContainerRef = useRef<HTMLDivElement | null>(null);
  const footerSectionRef = useRef<HTMLElement | null>(null);
  const [hideTopOnFooter, setHideTopOnFooter] = useState<boolean>(false);
  // FAQ open state: which item is expanded (null = none)
  const [openFaq, setOpenFaq] = useState<number | null>(null);

  useEffect(() => {
    const container = scrollContainerRef.current;
    const footer = footerSectionRef.current;
    if (!container || !footer) return;
    if (typeof IntersectionObserver === 'undefined') return;

    const io = new IntersectionObserver((entries) => {
      for (const e of entries) {
        // if footer is at least 60% visible within the scroll container, hide topbar
        if (e.isIntersecting && e.intersectionRatio >= 0.6) {
          setHideTopOnFooter(true);
        } else {
          setHideTopOnFooter(false);
        }
      }
    }, { root: container, threshold: [0.0, 0.25, 0.5, 0.6, 0.75, 1.0] });

    io.observe(footer);
    return () => io.disconnect();
  }, []);

  // RAF-driven ticker: single DOM node, immediate reset when fully left
  useEffect(() => {
    const span = smallTickerSpanRef.current;
    if (!span) return;
    if (typeof window === 'undefined') return;
    if (window.matchMedia && window.matchMedia('(prefers-reduced-motion: reduce)').matches) return;

    let rafId = 0;
    let lastTs: number | null = null;
    let x = window.innerWidth;

    // initialize styles to ensure consistent positioning
    span.style.position = 'absolute';
    span.style.top = '50%';
    span.style.left = '0';
    span.style.whiteSpace = 'nowrap';
    span.style.willChange = 'transform';
    span.style.transform = `translateX(${x}px) translateY(-50%)`;

    function step(ts: number) {
      if (!lastTs) lastTs = ts;
      const dt = (ts - lastTs) / 1000;
      lastTs = ts;
      const speed = 140; // px/s
      x -= speed * dt;
      const w = span.offsetWidth || 0;
      span.style.transform = `translateX(${x}px) translateY(-50%)`;
      if (x + w < 0) {
        // immediate wrap
        x = window.innerWidth;
        lastTs = null;
        span.style.transform = `translateX(${x}px) translateY(-50%)`;
      }
      rafId = requestAnimationFrame(step);
    }

    function onResize() {
      x = window.innerWidth;
      lastTs = null;
      span.style.transform = `translateX(${x}px) translateY(-50%)`;
    }

    window.addEventListener('resize', onResize);
    rafId = requestAnimationFrame(step);

    return () => {
      cancelAnimationFrame(rafId);
      window.removeEventListener('resize', onResize);
    };
  }, [smallTicker]);
  // Readiness flags for images
  const [collageReady, setCollageReady] = useState(false);
  const [gameReady, setGameReady] = useState(false);
  const [minigameResolved, setMinigameResolved] = useState(false);

  // Compute initial readiness: collage image, minigame config, and prize pool config
  useEffect(() => {
    const ready = collageReady && minigameResolved && (!gameUrl || gameReady) && prizePoolLoaded && poolLevelServerLoaded;
    if (!initialLoadDone) {
      if (ready) {
        setInitialLoadDone(true);
        setLoading(false);
      } else {
        setLoading(true);
      }
    }
  }, [collageReady, minigameResolved, gameUrl, gameReady, prizePoolLoaded, initialLoadDone, poolLevelServerLoaded]);
  // cycle logo animation: 0..5 every 20s (6 variants)
  const [logoAnim, setLogoAnim] = useState<number>(0);
  useEffect(() => {
    const id = setInterval(() => setLogoAnim(v => (v + 1) % 6), 20000);
    return () => clearInterval(id);
  }, []);

  // --- Animation Refs and helpers ---
  const coinBadgeRef = useRef<HTMLDivElement | null>(null);
  const testAnchorRef = useRef<HTMLDivElement | null>(null);
  const dailySourceGemRef = useRef<HTMLSpanElement | null>(null);

  function centerOf(el: Element | null) {
    if (!el) return { x: window.innerWidth / 2, y: window.innerHeight / 2 };
    const r = el.getBoundingClientRect();
    return { x: r.left + r.width / 2, y: r.top + r.height / 2 };
  }
  // Fly diamond animation: fly from origin element (if given) to badge
  function playGemFly(count = 10, fromEl?: Element | null) {
    const targetEl = coinBadgeRef.current;
    if (!targetEl) return;
    const target = centerOf(targetEl);
    const start = centerOf(fromEl || targetEl);

    const durMin = 650, durMax = 1100;
    for (let i = 0; i < count; i++) {
      const node = document.createElement('span');
      node.textContent = 'üíé';
      node.style.position = 'fixed';
      node.style.left = '0';
      node.style.top = '0';
      node.style.willChange = 'transform, opacity';
      node.style.pointerEvents = 'none';
      node.style.zIndex = '9998';
      node.style.fontSize = (14 + Math.random() * 10) + 'px';
      node.style.opacity = '0';
      document.body.appendChild(node);

      const dx = (Math.random() - 0.5) * 140;
      const dy = -60 - Math.random() * 120; // arc upward
      const cp = { x: start.x + dx, y: start.y + dy };
      const T = durMin + Math.random() * (durMax - durMin);
      const delay = i * 28;

      const t0 = performance.now() + delay;
      function tick(t: number) {
        const pRaw = (t - t0) / T;
        const p = Math.max(0, Math.min(1, pRaw));
        const ease = 1 - Math.pow(1 - p, 3); // easeOutCubic
        const x = (1 - ease) * (1 - ease) * start.x + 2 * (1 - ease) * ease * cp.x + ease * ease * target.x;
        const y = (1 - ease) * (1 - ease) * start.y + 2 * (1 - ease) * ease * cp.y + ease * ease * target.y;
        node.style.transform = `translate(${x}px, ${y}px)`;
        node.style.opacity = p < 0.1 ? String(p * 10) : p > 0.9 ? String(1 - (p - 0.9) * 10) : '1';
        if (p < 1) requestAnimationFrame(tick); else node.remove();
      }
      requestAnimationFrame(tick);
    }
  }

  // Helper: heutige Reward-Anzahl
  function todaysRewardCount() {
  const len = dailyRewards.length;
  const pos = currentDailyPos();           // 1..len
  if (dailySpecialItems[pos]) return 0;    // keine Diamanten an 7/14
  const idx = Math.max(0, Math.min(len - 1, pos - 1));
  return dailyRewards[idx] || 0;
}

  // Scale item quantity by total tickets today: +1 qty per 10k tickets, cap 99
  function scaledQty(base?: number) {
    const baseQty = typeof base === 'number' && base > 0 ? base : 1;
    const steps = Math.floor((ticketsTotalToday || 0) / 10000); // 10k tickets ‚Üí +1
    const q = baseQty + steps;
    return Math.min(99, q);
  }



  // Daily bonus UI state (layout only)
  const [showDaily, setShowDaily] = useState<boolean>(false);
  const [showAccount, setShowAccount] = useState<boolean>(false);
  const [showItems, setShowItems] = useState<boolean>(false);
  const [showNotifications, setShowNotifications] = useState<boolean>(false);
  
  // Function to close all modals before opening a new one
  const closeAllModals = () => {
    setShowDaily(false);
    setShowAccount(false);
    setShowItems(false);
    setShowNotifications(false);
    setShowPool(false);
  };
  
  // Adblock detector
  const [adblockDetected, setAdblockDetected] = useState<boolean>(false);
  const [adblockDismissed, setAdblockDismissed] = useState<boolean>(false);
  // --- Adblock detection: DOM bait + network bait + fetch probe (robust) ---
  useEffect(() => {
    let cancelled = false;

    // signal states
    let baitHidden = false;           // DOM bait removed/hidden
    let scriptBlocked: boolean | null = null; // external ads script failed
    let fetchBlocked: boolean | null = null;  // fetch probe failed

    const settle = () => {
      if (cancelled) return;
      // votes: network signals count heavier
      const votes = (baitHidden ? 1 : 0) + (scriptBlocked === true ? 2 : 0) + (fetchBlocked === true ? 2 : 0);
      const detected = (scriptBlocked === true) || (fetchBlocked === true) || votes >= 2; // majority OR any hard network block
      setAdblockDetected(detected);
    };

    // 1) DOM bait many blockers hide
    const bait = document.createElement('div');
    bait.className = 'adsbox ad adsbygoogle ad-banner ad-unit ad-container sponsored advertisement';
    bait.style.cssText = 'position:absolute; left:-9999px; top:-9999px; width:300px; height:250px; pointer-events:none; opacity:0;';
    bait.innerHTML = '&nbsp;';
    document.body.appendChild(bait);

    const checkBait = () => {
      try {
        const cs = window.getComputedStyle(bait);
        const zeroSize = (bait.offsetHeight === 0 && bait.offsetWidth === 0) || (parseInt(cs.height || '0', 10) === 0);
        const hidden = cs.display === 'none' || cs.visibility === 'hidden' || zeroSize || !bait.isConnected;
        baitHidden = hidden;
      } catch {
        baitHidden = true;
      } finally {
        settle();
      }
    };

    // 2) Script probe to a well‚Äëknown ads script (most blockers stop this)
    const s = document.createElement('script');
    s.src = 'https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js';
    s.async = true;
    s.onload = () => { if (!cancelled) { scriptBlocked = false; settle(); } };
    s.onerror = () => { if (!cancelled) { scriptBlocked = true; settle(); } };
    document.head.appendChild(s);

    // 3) Fetch probe (no‚Äëcors) ‚Äî adblockers typically cancel these requests
    (async () => {
      try {
        const ctrl = new AbortController();
        const to = window.setTimeout(() => ctrl.abort(), 2500);
        try {
          // most blockers cancel to *.googlesyndication.com; opaque ok, abort/error => blocked
          const res = await fetch('https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js', { mode: 'no-cors', signal: ctrl.signal });
          fetchBlocked = false; // request was not actively blocked
        } catch {
          fetchBlocked = true;
        } finally {
          window.clearTimeout(to);
          settle();
        }
      } catch {
        fetchBlocked = null; // leave undecided
        settle();
      }
    })();

    // initial and delayed DOM bait checks
    requestAnimationFrame(() => requestAnimationFrame(checkBait));
    const retry = window.setTimeout(checkBait, 1500);

    return () => {
      cancelled = true;
      try { bait.remove(); } catch {}
      try { s.remove(); } catch {}
      window.clearTimeout(retry);
    };
  }, []);
  const [claimError, setClaimError] = useState<string | null>(null);
  // --- Item System --- (Firestore-driven)
  // Firestore: config/shop
  // { items: { double_xp: { name: string, desc: string, price: number, active?: boolean }, double_tickets: { ... } } }
type ShopItem = { id: 'double_xp'|'double_tickets'|'ad_20_coins'; name: string; desc: string; price: number; active?: boolean; icon?: string };
  const [shopItems, setShopItems] = useState<ShopItem[]>([]);

  type ItemId = 'double_xp' | 'double_tickets' | 'ad_20_coins';
  const [itemsOwned, setItemsOwned] = useState<Record<ItemId, number>>({ double_xp: 0, double_tickets: 0, ad_20_coins: 0 });
  const [buyBusy, setBuyBusy] = useState<Record<ItemId, boolean>>({ double_xp: false, double_tickets: false, ad_20_coins: false });
  const [buyError, setBuyError] = useState<string | null>(null);
  const [effects, setEffects] = useState<Record<ItemId, { active?: boolean; untilMs?: number }>>({
    double_xp: {},
    double_tickets: {},
    ad_20_coins: {},
  });
  // live timer inside Items modal
  const [itemsTick, setItemsTick] = useState(0);
  const [nowMsItems, setNowMsItems] = useState<number>(0);

  useEffect(() => {
    if (!showItems) return;
    // Simply set time once when modal opens - no intervals!
    setNowMsItems(Date.now());
  }, [showItems]);
  // Subscribe to Firestore for shop items
  useEffect(() => {
    const fs = getFirestore();
    const unsub = onSnapshot(doc(fs, 'config', 'shop'), (snap) => {
      const data: any = snap.exists() ? snap.data() : null;
      // expected shape:
      // { items: { double_xp: { name, desc, price, active }, double_tickets: {...}, ad_20_coins: {...} } }
      const raw = data?.items || {};
      const out: ShopItem[] = [];
      // double_tickets from config if present
      const dt = raw['double_tickets'];
      if (dt && typeof dt.price === 'number') {
        out.push({
          id: 'double_tickets',
          name: dt.name || 'Doppelte Tickets',
          desc: dt.desc || '',
          price: dt.price,
          icon: '/icons/double_tickets.svg', // von .png zu .svg ge√§ndert
          active: dt.active !== false,
        });
      }
      // ad_20_coins: default enabled unless explicitly disabled in config
      const ad = raw['ad_20_coins'];
      if (!ad || ad?.active !== false) {
        out.push({
          id: 'ad_20_coins',
          name: (ad?.name) || 'Gratis Coins',
          desc: (ad?.desc) || '',
          price: typeof ad?.price === 'number' ? ad.price : 25, // von 20 auf 25 ge√§ndert
          icon: '/icons/coin-stack.svg',
          active: true,
        });
      }
      setShopItems(out);
    }, () => setShopItems([]));
    return () => unsub();
  }, []);
  const [streak, setStreak] = useState<number>(0);
  const [claimedToday, setClaimedToday] = useState<boolean>(false);
  // Daily rewards: 14 Tage, Darstellung in 2 Reihen √† 7
  const dailyRewards = [
    5, 5, 5, 10, 5,   // 1‚Äì5T
    5, 10, 5, 5, 5,   // 6‚Äì10  (Tag 7 = 10 Diamanten, Tag 8 = 5)
    10, 5, 5, 15      // 11‚Äì14
  ];
  // Special daily items: only day 14 ‚Üí double_tickets
  const dailySpecialItems: Record<number, { id: ItemId; label: string; emoji: string }> = {
    14: { id: 'double_tickets', label: '2√ó Tickets', emoji: 'üéüÔ∏è' },
  };

  const [claimLoading, setClaimLoading] = useState(false);
  const [confettiAt, setConfettiAt] = useState<number>(0);
  const confettiLockRef = useRef(false);
  const startConfetti = () => {
    if (confettiLockRef.current) return;
    confettiLockRef.current = true;
    setConfettiAt(Date.now());
    // unlock slightly after the animation finishes
    setTimeout(() => { confettiLockRef.current = false; }, 4500);
  };

  async function handleClaim() {
    if (!uid || claimLoading || claimedToday) return;
    setClaimError(null);
    setClaimLoading(true);
    try {
      const fsNow = serverNowBaseRef.current + (performance.now() - perfBaseRef.current);
      // Determine today‚Äôs reward index 1..14 using same logic as UI
      const dayPos = currentDailyPos();
      const special = dailySpecialItems[dayPos];
      const fn = httpsCallable(getFunctions(undefined, 'us-central1'), 'claimDaily');
      const res: any = await fn(special ? { requestItem: special.id } : {});
      console.log('[claimDaily] response', res?.data);
      if (res?.data?.ok === true) {
        startConfetti();
        setClaimedToday(true);
      } else if (res?.data?.code === 'already-claimed') {
        setClaimedToday(true);
      } else {
        const msg = res?.data?.message || 'Claim fehlgeschlagen';
        setClaimError(msg);
        console.error('[claimDaily] failed', res?.data);
      }
      // coins/streak/lastClaim werden via onSnapshot aktualisiert
    } catch (e: any) {
      const rawMsg = e?.message || String(e);
      const msg = (typeof rawMsg === 'string') ? rawMsg.toLowerCase() : '';
      const code = (e?.code || e?.name || '').toString().toLowerCase();
      const already = msg.includes('already-claimed') || code.includes('already-claimed') || (e?.details && JSON.stringify(e.details).includes('already-claimed'));
      if (already) {
        try {
          const fs = getFirestore();
          const now = serverNowBaseRef.current + (performance.now() - perfBaseRef.current);
          const todayId = new Intl.DateTimeFormat('en-CA', { timeZone: 'Europe/Berlin', year: 'numeric', month: '2-digit', day: '2-digit' }).format(new Date(now));
          const snap = await getDoc(doc(fs, 'users', uid!, 'claims', todayId));
          if (snap.exists()) {
            setClaimedToday(true);
            setClaimError(null);
            console.warn('[claimDaily] already-claimed verified by Firestore');
          } else {
            setClaimedToday(false);
            setClaimError('Bereits eingel√∂st gemeldet, aber kein Nachweis gefunden.');
            console.warn('[claimDaily] already-claimed without claim doc');
          }
        } catch (vErr) {
          setClaimError('Bereits eingel√∂st gemeldet, Pr√ºfung fehlgeschlagen.');
          console.error('[claimDaily] verify error', vErr);
        }
      } else {
        const details = e?.details ? ` (${JSON.stringify(e.details)})` : '';
        setClaimError(`Fehler: ${code || 'unknown'}${details ? ' ' + details : ''}`);
        console.error('[claimDaily] exception', e);
      }
    } finally {
      setClaimLoading(false);
    }
  }

  // Erweitere die Hilfsfunktionen um ticketsDateIdFromMs
  function ticketsDateIdFromMs(ms: number): string {
    const parts = berlinPartsFromMs(ms);
    const minutes = parts.hour * 60 + parts.minute + parts.second / 60;
    const cutoff = 20 * 60 + 15; // 20:15 Berlin time
    let target = { year: parts.year, month: parts.month, day: parts.day };
    const afterCutoff = minutes >= cutoff;
    
    if (afterCutoff) {
      target = shiftBerlinDay(target, 1); // Show tomorrow's tickets after 20:15
    }
    // Before 20:15: show today's tickets
    
    // DEBUG: Log tickets calculation
    const timeStr = `${String(parts.hour).padStart(2,'0')}:${String(parts.minute).padStart(2,'0')}:${String(parts.second).padStart(2,'0')}`;
    const resultDate = formatBerlinDay(target);
    console.log(`[ticketsDateIdFromMs] Berlin: ${timeStr}, minutes: ${minutes.toFixed(1)}, >= ${cutoff}? ${afterCutoff}, result: ${resultDate}`);
    
    return resultDate;
  }

  const [serverOffset, setServerOffset] = useState<number>(0); // ms: serverNow = Date.now() + serverOffset

  const areaRef = useRef<HTMLDivElement>(null);
  const serverNowBaseRef = useRef<number>(0); // epoch ms at last sync
  const perfBaseRef = useRef<number>(0);      // performance.now() at last sync




  function fmt(ms: number) {
    const s = Math.max(0, Math.floor(ms / 1000));
    const h = Math.floor(s / 3600);
    const m = Math.floor((s % 3600) / 60);
    const sec = s % 60;
    return h > 0 ? `${h}h ${m}m` : `${m}m ${sec}s`;
  }

  function berlinTodayId() {
    return raffleCollectionDateIdFromMs(Date.now());
  }
  useEffect(() => {
    const dayKey = `ticker:${berlinTodayId()}`;
    // Try daily cache first
    const cached = lsGet(dayKey);
    if (Array.isArray(cached) && cached.every((s: any) => typeof s === 'string')) {
      const base = (cached as string[]).join(' ‚Ä¢ ');
      setSmallTicker(base);
    }
    // Fallback: read once from Firestore and cache for the day
    (async () => {
      try {
        const fs = getFirestore();
        const snap = await getDoc(doc(fs, 'config', 'ticker'));
        const data: any = snap.exists() ? snap.data() : null;
        let msgs: string[] = [];
        if (Array.isArray(data)) {
          msgs = data.filter((s: any) => typeof s === 'string');
        } else if (Array.isArray(data?.messages)) {
          msgs = data.messages.filter((s: any) => typeof s === 'string');
        } else if (data && typeof data === 'object') {
          msgs = Object.values(data).filter((s: any) => typeof s === 'string');
        }
        const finalMsgs = msgs.length > 0 ? msgs : ['Platzhalter'];
        lsSet(dayKey, finalMsgs);
        const base = finalMsgs.join(' ‚Ä¢ ');
        setSmallTicker(base);
      } catch {
        const base = 'Platzhalter ‚Ä¢ News ‚Ä¢ Update';
        setSmallTicker(base);
      }
    })();
  }, []);
  function fmtHMS(ms: number) {
    const s = Math.max(0, Math.floor(ms / 1000));
    const h = String(Math.floor(s / 3600)).padStart(2, '0');
    const m = String(Math.floor((s % 3600) / 60)).padStart(2, '0');
    const sec = String(s % 60).padStart(2, '0');
    return `${h}:${m}:${sec}`;
  }

  function fmtMS(ms: number) {
    const s = Math.max(0, Math.floor(ms / 1000));
    const m = String(Math.floor(s / 60)).padStart(2, '0');
    const sec = String(s % 60).padStart(2, '0');
    return `${m}:${sec}`;
  }

  function nextLocal3hMsFrom(nowMs: number) {
    const d = new Date(nowMs);
    d.setMinutes(0, 0, 0);
    const h = d.getHours();
    const nextH = Math.floor(h / 3) * 3 + 3; // 0,3,6,9,12,15,18,21 ‚Üí next
    if (nextH >= 24) {
      d.setDate(d.getDate() + 1);
      d.setHours(nextH - 24);
    } else {
      d.setHours(nextH);
    }
    return d.getTime();
  }

  function msUntil20From(nowMs: number) {
    const now = new Date(nowMs);
    const target = new Date(nowMs);
    target.setHours(20, 0, 0, 0);
    if (now.getTime() >= target.getTime()) {
      target.setDate(target.getDate() + 1);
    }
    return target.getTime() - now.getTime();
  }

  function sameYMDInBerlin(aMs: number, bMs: number) {
    const opts: Intl.DateTimeFormatOptions = { timeZone: 'Europe/Berlin', year: 'numeric', month: '2-digit', day: '2-digit' };
    const fmt = new Intl.DateTimeFormat('en-CA', opts); // stable YYYY-MM-DD
    const A = fmt.format(new Date(aMs));
    const B = fmt.format(new Date(bMs));
    return A === B;
  }

  const lastClaimMsRef = useRef<number | null>(null);
function berlinYMD(ms: number) {
  const opt: Intl.DateTimeFormatOptions = { timeZone: 'Europe/Berlin', year: 'numeric', month: '2-digit', day: '2-digit' };
  return new Intl.DateTimeFormat('en-CA', opt).format(new Date(ms));
}
function isBerlinYesterday(lcMs: number | null, nowMs: number) {
  if (!lcMs) return false;
  const DAY = 24 * 60 * 60 * 1000;
  return berlinYMD(lcMs) === berlinYMD(nowMs - DAY);
}
function currentDailyPos() {
  const len = dailyRewards.length;
  if (!streak || streak <= 0) return 1;
  const nowMs = serverNowBaseRef.current + (performance.now() - perfBaseRef.current);
  if (claimedToday) return ((streak - 1) % len) + 1;     // heute schon geholt
  if (isBerlinYesterday(lastClaimMsRef.current, nowMs)) return (streak % len) + 1; // gestern geholt ‚Üí n√§chste Kachel
  return 1; // Serie gebrochen ‚Üí Tag 1
}


  useEffect(() => {
    const auth = getAuth();
    const unsub = onAuthStateChanged(auth, (u) => {
      if (u) {
        setUid(u.uid);
      } else {
        setUid(null);
        setCoins(0);
        setStreak(0);
        setClaimedToday(false);
        setShowItems(false);
      }
    });
    return () => unsub();
  }, []);

  useEffect(() => {
    const db = getDatabase();
    const offRef = dbRef(db, "/.info/serverTimeOffset");
    const unsub = onValue(offRef, (snap) => {
      const off = snap.val();
      setServerOffset(typeof off === 'number' ? off : 0);
    });
    return () => unsub();
  }, []);

  useEffect(() => {
    // Re-sync bases whenever offset changes
    serverNowBaseRef.current = Date.now() + serverOffset;
    perfBaseRef.current = performance.now();
  }, [serverOffset]);


  useEffect(() => {
    if (!uid) return;
    const fs = getFirestore();
    const unsub = onSnapshot(doc(fs, "users", uid), (snap) => {
      if (snap.exists()) {
        const data: any = snap.data();
        setCoins(typeof data.coins === "number" ? data.coins : 0);
        const s = typeof data.streak === 'number' ? data.streak : 0;
        setStreak(s);
        const lc = data.lastClaim?.toMillis ? data.lastClaim.toMillis() : (typeof data.lastClaim === 'number' ? data.lastClaim : null);
        lastClaimMsRef.current = lc ?? null;
        const serverNow = serverNowBaseRef.current + (performance.now() - perfBaseRef.current);
        if (lc) {
          const isTodayClaim = sameYMDInBerlin(lc, serverNow);
          setClaimedToday(isTodayClaim);
        } else {
          setClaimedToday(false);
        }
        if (typeof data.photoURL === 'string' && data.photoURL) {
          setProfilePhoto(withAvatarCache(data.photoURL));
        }
        // Items owned
        const it = data.items;
        const dx = typeof it?.double_xp === 'number' ? it.double_xp : 0;
        const dt = typeof it?.double_tickets === 'number' ? it.double_tickets : 0;
        setItemsOwned({ double_xp: dx, double_tickets: dt, ad_20_coins: 0 });
        // Effects with fallback: if `until` missing, derive from `activatedAt + 10min`
        const eff = data.effects || {};
        const toMs = (v: any) => (v?.toMillis ? v.toMillis() : (typeof v === 'number' ? v : undefined));
        const deriveUntil = (node: any) => {
          const u = toMs(node?.until);
          if (typeof u === 'number') return u;
          const a = toMs(node?.activatedAt);
          return typeof a === 'number' ? a + 10 * 60 * 1000 : undefined;
        };
        setEffects({
          double_xp: { active: !!eff?.double_xp?.active, untilMs: deriveUntil(eff?.double_xp) },
          double_tickets: { active: !!eff?.double_tickets?.active, untilMs: deriveUntil(eff?.double_tickets) },
          ad_20_coins: {},
        });
      } else {
        setCoins(0);
        setStreak(0);
        setClaimedToday(false);
        setItemsOwned({ double_xp: 0, double_tickets: 0, ad_20_coins: 0 });
        setEffects({ double_xp: {}, double_tickets: {}, ad_20_coins: {} });
      }
    });
    return () => unsub();
  }, [uid]);
  // --- Item purchase function ---
  async function watchAdForCoins() {
    if (!uid) { setBuyError('Bitte zuerst einloggen.'); return; }
    setBuyBusy((s) => ({ ...s, ad_20_coins: true }));
    try {
      // TODO: Integrate real rewarded ad SDK. For now, call server to grant reward.
      const fn = httpsCallable(getFunctions(undefined, 'us-central1'), 'grantCoinsForAd');
      const res: any = await fn({ reward: 25 }); // von 20 auf 25 ge√§ndert
      if (!res || res?.data?.ok !== true) {
        const msg = res?.data?.message || 'Keine Best√§tigung vom Server';
        throw new Error(msg);
      }
      // Coins update via onSnapshot listener.
    } catch (e: any) {
      const msg = e?.message || String(e);
      setBuyError(`Werbung fehlgeschlagen: ${msg}`);
    } finally {
      setBuyBusy((s) => ({ ...s, ad_20_coins: false }));
 }
  }

  async function buyItem(id: ItemId) {
    if (id === 'ad_20_coins') { await watchAdForCoins(); return; }
    if (!uid) { setBuyError('Bitte zuerst einloggen.'); return; }
    setBuyError(null);
    setBuyBusy((s) => ({ ...s, [id]: true }));
    const fs = getFirestore();
    const userRef = doc(fs, 'users', uid);
    // Find the catalog item from shopItems
    const catalogItem = shopItems.find(item => item.id === id);
    // Add debug context for transaction
    const ctx = { uid, itemId: id, catalogItem: catalogItem?.name };
    const dbg: any = { preflight: ctx };
    if (!catalogItem) { setBuyError('Item nicht verf√ºgbar.'); setBuyBusy((s) => ({ ...s, [id]: false })); return; }
    try {
      await runTransaction(fs, async (tx) => {
        const snap = await tx.get(userRef);
        if (!snap.exists()) throw new Error('Profil nicht gefunden');
        const data: any = snap.data() || {};
        const coins: number = typeof data.coins === 'number' ? data.coins : 0;
        // Load server-side price inside the same transaction
        const shopSnap = await tx.get(doc(fs, 'config', 'shop'));
        const shop: any = shopSnap.exists() ? shopSnap.data() : {};
        const priceMap = shop?.items || {};
        const serverPrice = typeof priceMap?.[id]?.price === 'number' ? priceMap[id].price : catalogItem.price;
        const active = (priceMap?.[id]?.active !== false);
        if (!active) throw new Error('Item nicht verf√ºgbar');
        if (coins < serverPrice) throw new Error('Nicht genug üíé');
        const items = { ...(data.items || {}) };
        const current = typeof items[id] === 'number' ? items[id] : 0;
        // Enforce single ownership: cannot buy if already owned (max 1)
        if (current >= 1) throw new Error('Nur ein Exemplar erlaubt');
        items[id] = current + 1;
        // capture attempted write for debug
        (dbg.tx = dbg.tx || {}).read = {
          coinsOld: coins,
          itemsOld: { [id]: current },
          serverPrice,
          active,
        };
        (dbg.tx = dbg.tx || {}).write = {
          coinsNew: coins - serverPrice,
          itemsNew: { [id]: items[id] },
          keys: Object.keys({ coins: coins - serverPrice, items, updatedAt: '<serverTimestamp>' })
        };
        tx.update(userRef, { coins: coins - serverPrice, items, updatedAt: serverTimestamp() });
      });
    } catch (e: any) {
      const code = e?.code || e?.name || 'unknown-error';
      const msg = e?.message || String(e);
      let hint = '';
      if (code === 'permission-denied') {
        hint = 'Hinweis: Firestore-Rules haben das Update abgelehnt. Pr√ºfe config/shop Preise & active, Rules-Branch f√ºr Kauf, und ob nur {coins, items, updatedAt} ge√§ndert werden.';
      } else if (code === 'failed-precondition' || code === 'aborted') {
        hint = 'Hinweis: Transaktion abgebrochen. M√∂gliche Race Condition oder veraltete Daten.';
      }
      const extra = `Kontext: ${JSON.stringify(ctx)} | TX: ${JSON.stringify(dbg)}`;
      setBuyError(`Kauf fehlgeschlagen [${code}]: ${msg}. ${hint} ${extra}`);
      console.error('[buyItem] error', { code, msg, ctx, dbg, raw: e });
    } finally {
      setBuyBusy((s) => ({ ...s, [id]: false }));
    }
  }

  // --- Activate a single owned item ---
  async function useItem(id: ItemId) {
    if (id === 'ad_20_coins') { await watchAdForCoins(); return; }
    if (!uid) { setBuyError('Bitte zuerst einloggen.'); return; }
    setBuyError(null);
    setBuyBusy((s) => ({ ...s, [id]: true }));
    try {
      const fs = getFirestore();
      const userRef = doc(fs, 'users', uid);
      await runTransaction(fs, async (tx) => {
        const snap = await tx.get(userRef);
        if (!snap.exists()) throw new Error('Profil nicht gefunden');
        const data: any = snap.data() || {};
        const itemsData: any = data.items || {};
        const owned = typeof itemsData[id] === 'number' ? itemsData[id] : 0;
        if (owned <= 0) throw new Error('Kein Item vorhanden');
        const newCount = owned - 1;

        const effects: any = { ...(data.effects || {}) };
        // compute server-relative now and set 10 minutes duration
        const serverNow = serverNowBaseRef.current + (performance.now() - perfBaseRef.current);
        const untilMs = Math.floor(serverNow + 10 * 60 * 1000);
        effects[id] = { active: true, activatedAt: serverTimestamp(), until: untilMs };

        // Only update the nested counter for this item to avoid overwriting other entries
        const updates: any = { effects, updatedAt: serverTimestamp() };
        (updates as any)[`items.${id}`] = newCount;
        tx.update(userRef, updates);
      });
    } catch (e: any) {
      const code = e?.code || e?.name || 'unknown-error';
      const msg = e?.message || String(e);
      setBuyError(`Verwenden fehlgeschlagen [${code}]: ${msg}`);
      console.error('[useItem] error', e);
    } finally {
      setBuyBusy((s) => ({ ...s, [id]: false }));
    }
  }
  useEffect(() => {
    if (!uid) return;
    const fs = getFirestore();
    let unsub: (() => void) | null = null;
    let currentDayId: string | null = null;

    const subscribeForDay = (dayId: string) => {
      console.log('[tickets] subscribe', { uid, dayId });
      unsub = onSnapshot(
        doc(fs, 'users', uid, 'countersByDay', dayId),
        (snap) => {
          const data: any = snap.exists() ? snap.data() : null;
          const raw = typeof data?.tickets === 'number' ? data.tickets : 0;
          console.log('[tickets] snap', {
            day: dayId,
            exists: snap.exists(),
            fromCache: snap.metadata?.fromCache ?? undefined,
            tickets: data?.tickets,
            data,
          });
          setTicketsToday(Math.max(0, raw));
        },
        (err) => {
          console.warn('[tickets] snap error', err);
          setTicketsToday(0);
        }
      );

      // Hole einmal direkt vom Server f√ºr initiale Synchronisation
      getDocFromServer(doc(fs, 'users', uid, 'countersByDay', dayId))
        .then((snap) => {
          const data: any = snap.exists() ? snap.data() : null;
          const raw = typeof data?.tickets === 'number' ? data.tickets : null;
          if (typeof raw === 'number' && isFinite(raw)) {
            setTicketsToday(Math.max(0, raw));
          }
        })
        .catch((err) => {
          console.warn('[tickets] server get error', err);
        });
    };

    const ensureSubscription = () => {
      const serverNow = serverNowBaseRef.current + (performance.now() - perfBaseRef.current);
      // Verwende ticketsDateIdFromMs statt raffleCollectionDateIdFromMs
      const dayId = ticketsDateIdFromMs(serverNow);
      
      // DEBUG: Force refresh for debugging
      const berlinParts = berlinPartsFromMs(serverNow);
      const timeStr = `${String(berlinParts.hour).padStart(2,'0')}:${String(berlinParts.minute).padStart(2,'0')}`;
      console.log(`[tickets ensureSubscription] Berlin: ${timeStr}, dayId: ${dayId}, currentDayId: ${currentDayId}, serverSynced: ${serverNowBaseRef.current > 0}`);
      

      
      if (dayId === currentDayId) return;
      currentDayId = dayId;
      if (unsub) {
        unsub();
        unsub = null;
      }
      setTicketsToday(0);
      subscribeForDay(dayId);
    };

    // FORCE IMMEDIATE REFRESH - Clear currentDayId to ensure subscription updates (only once)
    if (currentDayId) {
      console.log(`[FORCE RESET] Clearing currentDayId from "${currentDayId}" to force refresh`);
      currentDayId = '';
    }
    

    
    ensureSubscription();
    const interval = setInterval(ensureSubscription, 60 * 1000);

    return () => {
      if (unsub) unsub();
      clearInterval(interval);
    };
  }, [uid]);

    useEffect(() => {
      // use local public asset for parallax shadow (not Firebase)
      setShadowUrl("/collage-shadow.png");

      const fs = getFirestore();
      const unsub = onSnapshot(doc(fs, "config", "currentMinigame"), async (snap) => {
        const data = snap.data();
        if (data && data.nextAt?.toMillis) {
          let ts = data.nextAt.toMillis();
          const snapToHour = new Date(ts);
          snapToHour.setMinutes(0, 0, 0);
          ts = snapToHour.getTime();

          const serverNow = serverNowBaseRef.current + (performance.now() - perfBaseRef.current);
          if (ts <= serverNow) ts = nextLocal3hMsFrom(serverNow);
          setNextAtMs(ts);
        } else {
          const serverNow = serverNowBaseRef.current + (performance.now() - perfBaseRef.current);
          setNextAtMs(nextLocal3hMsFrom(serverNow));
        }
        setMinigameResolved(false);
        try {
          // Derive identifier for current minigame
          const nameSource = (data && (data.slug || data.id || data.key || data.name)) || null;
          let previewUrl: string | null = null;
          if (nameSource) {
            const base = String(nameSource).replace(/\.(png|jpg|jpeg|webp)$/i, '');
            setGameSlug(base); // set slug state for title
            const file = toSlugFilename(base); // e.g. "tap-rush.png"
            if (file) {
              // Use Next.js public asset directly. No HEAD probe.
              const publicUrl = `/minigame-previews/${file}?v=${Date.now()}`;
              previewUrl = publicUrl;
            }
          } else {
            setGameSlug(null);
          }
          setGameReady(!previewUrl);
          setGameUrl(previewUrl);
        } catch (e) {
          setGameUrl(null);
          setGameReady(true);
          setGameSlug(null);
        } finally {
          setMinigameResolved(true);
        }
      });
      return () => unsub();
    }, []);

  // Mark collage as ready if no collage URL is set
  useEffect(() => {
    if (!url) setCollageReady(true);
  }, [url]);

  // Firestore schema expected (new):
  // doc: config/prizePools
  // {
  //   "level-00": {
  //     "item-01": { name: string, amount: number, image?: string },
  //     "item-02": { ... },
  //     totalRewards?: number // total number of cards to show for this level
  //   },
  //   "level-01": { ... }
  //   ...
  //   totalRewards?: number // optional fallback for all levels
  // }
  // Notes:
  // - image accepts Next.js public path starting with "/", Firebase Storage path, or https URL
  // - Collage is now static and loaded from /prizes/drop-collage.png
  // Subscribe to Firestore for prize pool config
  useEffect(() => {
    const fs = getFirestore();
    const unsub = onSnapshot(doc(fs, 'config', 'prizePools'), async (snap) => {
      const data: any = snap.exists() ? snap.data() : null;
      // Expect structure: { "level-00": { "item-01": { name, amount, image }, ... }, "level-01": { ... }, ... }
      const levelEntries = Object.entries(data || {})
        .filter(([k, v]) => /^level-\d{2}$/i.test(k) && v && typeof v === 'object');
      // sort by level number asc
      levelEntries.sort((a, b) => parseInt(a[0].slice(6), 10) - parseInt(b[0].slice(6), 10));

      const levels: PrizeLevel[] = levelEntries.map(([levelKey, levelObj]: [string, any], idx) => {
        const numericIndex = Number.parseInt(levelKey.slice(6), 10);
        const levelIndex = Number.isFinite(numericIndex) ? numericIndex : idx;
        const rawTicketsNeeded = levelObj?.['tickets-needed'];
        const parsedTicketsNeeded = Number(rawTicketsNeeded);
        const ticketsNeeded = Number.isFinite(parsedTicketsNeeded)
          ? parsedTicketsNeeded
          : levelIndex * 100;
        const lvlTotal = typeof levelObj?.totalRewards === 'number' ? levelObj.totalRewards : undefined;
        // items: keys like item-01
        const itemEntries = Object.entries(levelObj)
          .filter(([k, v]) => /^item-\d{2}$/i.test(k) && v && typeof v === 'object');
        itemEntries.sort((a, b) => parseInt(a[0].slice(5), 10) - parseInt(b[0].slice(5), 10));
        const items: PrizeItem[] = itemEntries.map(([, it]: [string, any]) => ({
          title: typeof it?.name === 'string' ? it.name : undefined,
          qty: typeof it?.amount === 'number' ? it.amount : undefined,
          image: typeof it?.image === 'string' ? it.image : undefined,
        }));
        return { levelIndex, ticketsNeeded, items, totalRewards: lvlTotal } as PrizeLevel;
      });

      setPrizeLevels(levels);
      // build per-level totals and set current totalRewards
      const fallbackTotal = typeof (data?.totalRewards) === 'number' ? data.totalRewards : 0;
      const totals = levels.map(lv => (typeof lv.totalRewards === 'number' ? lv.totalRewards! : fallbackTotal));
      setLevelTotals(totals);
      const idxForTotal = findLevelArrayIndex(levels, effectivePoolLevel);
      if (idxForTotal >= 0 && idxForTotal < totals.length) {
        setTotalRewards(totals[idxForTotal] || 0);
      } else {
        setTotalRewards(totals[0] || 0);
      }
      // Collage logic removed - now using static collage

      // Select items for current level (capped)
      if (levels.length > 0) {
        const idx = findLevelArrayIndex(levels, poolLevel);
        const safeIdx = idx >= 0 && idx < levels.length ? idx : 0;
        const items = Array.isArray(levels[safeIdx]?.items) ? levels[safeIdx]!.items! : [];
        setPoolItems(items);
      } else {
        setPoolItems([]);
      }

      setPrizePoolLoaded(true);
    }, () => setPoolItems([]));
    return () => unsub();
  }, [effectivePoolLevel]);

  // Update poolItems when poolLevel changes and prizeLevels exists; also update totalRewards for current level
  useEffect(() => {
    if (!prizeLevels || prizeLevels.length === 0) return;
    const idx = findLevelArrayIndex(prizeLevels, effectivePoolLevel);
    const safeIdx = idx >= 0 && idx < prizeLevels.length ? idx : 0;
    const items = Array.isArray(prizeLevels[safeIdx]?.items) ? prizeLevels[safeIdx]!.items! : [];
    setPoolItems(items);
    if (levelTotals && levelTotals.length > safeIdx) {
      setTotalRewards(levelTotals[safeIdx] || 0);
    }
  }, [effectivePoolLevel, prizeLevels, levelTotals]);

  // Load static collage from local public folder
  useEffect(() => {
    let cancelled = false;
    
    async function loadStaticCollage() {
      try {
        setCollageReady(false);
        setError(null);
        
        // Use a static collage image from public folder
        const staticCollageUrl = '/prizes/drop-collage.png';
        
        // DISABLED: Preloading for performance testing
        // Skip preloading - direct image loading
        
        if (!cancelled) {
          setUrl(staticCollageUrl);
          setError(null);
          setCollageReady(true);
        }
      } catch (e) {
        if (!cancelled) {
          const errorUrl = '/drop-error.png';
          // DISABLED: Error image preloading for performance testing
          setUrl(errorUrl);
          setError(null);
          setCollageReady(true);
        }
      }
    }

    loadStaticCollage();
    return () => { cancelled = true; };
  }, []); // No dependencies since we use a static image


  // Resolve storage paths to URLs when poolItems changes
  useEffect(() => {
    let cancelled = false;
    (async () => {
      const out: { title?: string; qty?: number; url: string }[] = [];
      for (const it of poolItems) {
        try {
          const title = it.title; const qty = it.qty;
          const img = it.image || '';
          let url = '';
          const candidates: string[] = [];
          if (img) candidates.push(img);
          const fn = toSlugFilename(title);
          if (fn) {
            candidates.push(`/prizes/${fn}`);      // Next.js public asset
            candidates.push(`prizes/${fn}`);       // Firebase Storage fallback
          }
          for (const c of candidates) {
            try {
              url = await getCachedDownloadURL(c);
              if (url) break;
            } catch {/* try next */}
          }
          if (!url) url = '/prizes/placeholder.png';
          out.push({ title, qty, url });
        } catch { /* ignore single item errors */ }
      }
      // Append not-disclosed placeholders up to totalRewards
      try {
        const currentTotal = out.reduce((acc, it) => acc + scaledQty(it.qty), 0);
        const missing = Math.max(0, (totalRewards || 0) - currentTotal);
        if (missing > 0) {
          const placeholderUrl = '/prizes/not-disclosed.png';
          for (let i = 0; i < missing; i++) {
            out.push({ title: 'Not disclosed', qty: 1, url: placeholderUrl });
          }
        }
      } catch {}
      if (!cancelled) setPoolResolved(out);
    })();
    return () => { cancelled = true; };
  }, [poolItems, totalRewards]);

  useEffect(() => {
    if (!nextAtMs) { setRemaining(""); return; }
    let raf = 0;
    const tick = () => {
      const elapsed = performance.now() - perfBaseRef.current;
      const serverNow = serverNowBaseRef.current + elapsed; // ms
      const secNowMs = Math.floor(serverNow / 1000) * 1000; // gemeinsame Sekundentaktung
      setRemaining(fmt(nextAtMs - secNowMs));
      raf = requestAnimationFrame(tick);
    };
    raf = requestAnimationFrame(tick);
    return () => cancelAnimationFrame(raf);
  }, [nextAtMs]);

  useEffect(() => {
    let raf = 0;
    const loop = () => {
      const elapsed = performance.now() - perfBaseRef.current;
      const serverNow = serverNowBaseRef.current + elapsed; // ms
      const secNowMs = Math.floor(serverNow / 1000) * 1000; // gemeinsame Sekundentaktung
      setUntil20(fmtHMS(msUntil20From(secNowMs)));
      raf = requestAnimationFrame(loop);
    };
    raf = requestAnimationFrame(loop);
    return () => cancelAnimationFrame(raf);
  }, []);

  const handleMouseMove = (e: React.MouseEvent<HTMLDivElement>) => {
    const el = areaRef.current;
    if (!el) return;
    const rect = el.getBoundingClientRect();
    const cx = rect.left + rect.width / 2;
    const cy = rect.top + rect.height / 2;
    // Normalized in range [-1, 1]
    const nx = (e.clientX - cx) / (rect.width / 2);
    const ny = (e.clientY - cy) / (rect.height / 2);
    const max = 10; // px, reduced effect (half as strong)
    const x = Math.max(-1, Math.min(1, nx)) * max;
    const y = Math.max(-1, Math.min(1, ny)) * max;
    setOffset({ x, y });
  };


  // Auto-open profile popup if profile is incomplete
  useEffect(() => {
    if (authReady && mustComplete) {
      closeAllModals();
      setShowAccount(true);
    }
  }, [authReady, mustComplete]);

  // Auto-close profile popup once user is ready and no completion needed
  useEffect(() => {
    if (authReady && !mustComplete) {
      setShowAccount(false);
    }
  }, [authReady, mustComplete]);

  // Close Account modal when profile panel signals success
  useEffect(() => {
    const onClose = () => {
      try { setShowAccount(false); } catch {}
    };
    const onMsg = (e: MessageEvent) => {
      if (e?.data && e.data.type === 'drop:account-close') onClose();
    };
    window.addEventListener('drop:account-close' as any, onClose);
    window.addEventListener('message', onMsg);
    return () => {
      window.removeEventListener('drop:account-close' as any, onClose);
      window.removeEventListener('message', onMsg);
    };
  }, []);
  // Demo: Yesterday's winners (test view)
  // const demoWinnersData = [
  //   { name: 'Lena', prize: '5‚Ç¨ Steam', time: '22:13' },
  //   { name: 'Max', prize: '500 V-Bucks', time: '21:47' },
  //   { name: 'Sara', prize: 'LoL RP 5‚Ç¨', time: '20:05' },
  //   { name: 'Jonas', prize: 'Gamer Supps', time: '19:52' },
  //   { name: 'Mia', prize: '5‚Ç¨ Steam', time: '18:11' },
  // ];
  return (
    <>
    {loading && (
      <div className="fixed inset-0 bg-black flex items-center justify-center z-[9999]">
        <div className="w-12 h-12 border-4 border-white/40 border-t-white rounded-full animate-spin" />
      </div>
    )}
  
  {/* Hidden asset preloading */}
  <div style={{ position: 'absolute', left: '-9999px', top: '-9999px', visibility: 'hidden', pointerEvents: 'none' }} aria-hidden="true">
    <img src="/icons/trophy.svg" alt="" />
    <img src="/icons/ad-icon.svg" alt="" />
    <img src="/icons/free-coins.svg" alt="" />
    <img src="/icons/double_tickets.svg" alt="" />
    <img src="/adblock-warning.png" alt="" />
  </div>
  
  {/* Sticky Header Elements */}
  <div ref={null} className={`fixed top-0 left-0 right-0 z-50 transition-opacity duration-300 ${hideTopOnFooter ? 'opacity-0 pointer-events-none' : 'opacity-100'}`} style={{ backfaceVisibility: 'hidden', willChange: 'transform', transform: 'translateZ(0)' }}>
      {/* Tiny scroll banner */}
      <div className="h-6 bg-black text-white" style={{ backfaceVisibility: 'hidden' }}>
        <div ref={smallTickerContainerRef} className="small-ticker-wrap w-full h-full">
          <div className="small-ticker-track relative h-full">
            <span ref={smallTickerSpanRef} className="small-ticker-text">{smallTicker}</span>
          </div>
        </div>
      </div>
      
      {/* Combined sticky header */}
      <div className="h-14 bg-black" style={{ backfaceVisibility: 'hidden' }}>
        {/* Left: Logo */}
        <div className="absolute left-4 top-1/2 -translate-y-1/2 z-10">
          <img src="/logo.png" alt="DROP" className={`h-4 w-auto select-none drop-logo drop-anim-${logoAnim}`} />
        </div>
        
        {/* Center: Coins Badges */}
        <div className="absolute left-1/2 top-1/2 -translate-x-1/2 -translate-y-1/2 flex items-center gap-3 z-[60] pointer-events-none">
          <div className="flex items-center gap-3">
            {/* Coins */}
            <div ref={coinBadgeRef} className="flex items-center gap-2 rounded-full bg-white text-black text-sm font-semibold shadow-sm border border-black/10 select-none px-4 py-1.5 pointer-events-auto">
              <img
                src="/icons/coin.svg"
                alt="Coin"
                width={20}
                height={20}
                className="inline-block align-middle select-none pointer-events-none"
              />
              <span className="font-semibold text-base tabular-nums">{coins}</span>
            </div>
            {/* Tickets */}
            <div className="flex items-center gap-2 rounded-full bg-white text-black text-sm font-semibold shadow-sm border border-black/10 select-none px-4 py-1.5 pointer-events-auto">
              <img
                src="/icons/ticket.svg"
                alt="Tickets"
                width={20}
                height={20}
                className="inline-block align-middle select-none pointer-events-none"
              />
              <span className="font-semibold text-base tabular-nums">{ticketsBadgeText}</span>
            </div>
            {/* Streak */}
            <div
              onClick={() => { closeAllModals(); setShowDaily(true); }}
              className="flex items-center gap-2 rounded-full bg-white text-black text-sm font-semibold shadow-sm border border-black/10 select-none px-4 py-1.5 pointer-events-auto cursor-pointer hover:opacity-90"
              role="button"
              aria-label="T√§glicher Bonus"
            >
              <img
                src="/icons/flame.png"
                alt="Streak"
                width={20}
                height={20}
                className="select-none pointer-events-none align-middle"
                style={{ imageRendering: 'pixelated' }}
              />
              <span className="font-semibold text-base tabular-nums">{Math.max(0, streak || 0)}</span>
            </div>
          </div>
        </div>
        
        {/* Right: Navigation buttons */}
        <div className="absolute right-4 top-1/2 -translate-y-1/2 flex items-center gap-3 z-10">
          {/* Performance test spinner */}
          <div className="test-spinner h-6 w-6"></div>
          
          <button onClick={() => { closeAllModals(); setShowNotifications(true); }} aria-label="Benachrichtigungen" className="h-8 w-8 flex items-center justify-center">
            <img 
              src="/icons/bell.png" 
              alt="Benachrichtigungen" 
              className="h-8 w-8 select-none pointer-events-none" 
              style={{ imageRendering: "pixelated" }}
            />
          </button>
          {uid && (
            <button onClick={() => { closeAllModals(); setShowItems(true); }} aria-label="Items">
              <img
                src="/items/items-icon.png"
                alt=""
                aria-hidden="true"
                className="h-8 w-8 select-none pointer-events-none"
                style={{ imageRendering: 'pixelated' }}
                onError={(e) => { e.currentTarget.onerror = null; e.currentTarget.src = '/items/pixel-items.png'; }}
              />
            </button>
          )}
          {testEnabled && (
            <button onClick={() => setShowTest(true)} aria-label="Test-Terminal" className="h-8 px-2 rounded bg-white/10 text-white text-xs border border-white/20">
              Test
            </button>
          )}
          <button onClick={() => { closeAllModals(); setShowAccount(true); }} aria-label="Account">
            <img
              src={uid && profilePhoto ? profilePhoto : "/profile-icon.png"}
              alt="Profil"
              className="h-8 w-8 select-none cursor-pointer rounded-full object-cover"
            />
          </button>
        </div>
      </div>
    </div>
    
  <div ref={scrollContainerRef} className="h-screen w-screen overflow-y-scroll overflow-x-hidden snap-y snap-mandatory pt-20">
      <div className="relative h-screen w-screen bg-black text-white flex flex-col overflow-hidden snap-start snap-always">
      {/* Animated red gradient over black */}
      <div
        aria-hidden
        className="absolute inset-0 z-0 pointer-events-none"
        style={{
          backgroundImage: `
  radial-gradient(2000px 1500px at 20% -5%,   rgba(255,60,60,0.44), rgba(0,0,0,0) 78%),
  radial-gradient(2200px 1600px at 80% 5%,    rgba(220,40,40,0.38), rgba(0,0,0,0) 75%),
  radial-gradient(2400px 1800px at 50% 115%,  rgba(244,63,94,0.40), rgba(0,0,0,0) 76%),
  radial-gradient(1600px 1200px at 10% 85%,   rgba(255,70,70,0.40), rgba(0,0,0,0) 76%),
  radial-gradient(1800px 1300px at 90% 80%,   rgba(235,50,60,0.36), rgba(0,0,0,0) 76%),
  radial-gradient(2000px 1400px at 50% 40%,   rgba(255,0,0,0.34),   rgba(0,0,0,0) 82%),
  radial-gradient(1500px 1100px at 5% 50%,    rgba(255,80,80,0.34), rgba(0,0,0,0) 75%),
  /* two mega-blobs left/right to stabilize ~50% red coverage */
  radial-gradient(3000px 2200px at -10% 50%,  rgba(220,30,30,0.06), rgba(0,0,0,0) 82%),
  radial-gradient(3000px 2200px at 110% 50%,  rgba(220,30,30,0.06), rgba(0,0,0,0) 82%)
`,
          backgroundSize: '160% 160%, 160% 160%, 160% 160%, 170% 170%, 170% 170%, 180% 180%, 160% 160%, 200% 200%, 200% 200%',
          backgroundPosition: '0% 0%, 100% 0%, 50% 100%, 10% 85%, 90% 80%, 50% 40%, 5% 50%, 0% 50%, 100% 50%',
          animation: 'gradientShift 28s ease-in-out infinite alternate'
        }}
      />
      {/* Global scanline overlay */}
      <div aria-hidden className="absolute inset-0 z-[1] pointer-events-none scanlines" />

      {/* Adblock Modal */}
      {adblockDetected && !adblockDismissed && (
        <div className="fixed inset-0 z-40 flex items-center justify-center">
          <div className="absolute inset-0 bg-black/80" />
          <div className="relative bg-white text-black rounded-2xl shadow-xl w-[min(92vw,560px)] max-w-[640px] p-6">
            <img
              src="/adblock-warning.png"
              alt="Adblock Warning"
              className="mx-auto mb-2 h-40 sm:h-48 w-auto max-w-[70%] object-contain"
            />
            <div>
              <h2 className="mt-1 text-2xl sm:text-3xl font-extrabold text-center text-black">Adblocker erkannt</h2>
              <p className="text-sm text-gray-600 text-center mt-1">
                Bitte deaktiviere deinen Adblocker oder f√ºge eine Ausnahme hinzu.
              </p>
              <p className="text-sm text-gray-600 text-center mt-1">
                Mehr Werbung = mehr Rewards :)
              </p>
            </div>
          </div>
        </div>
      )}

      {/* Notifications Modal */}
      {showNotifications && (
        <div className="fixed inset-0 z-40 flex items-center justify-center opacity-100 pointer-events-auto">
          <div className="absolute inset-0 bg-black/80" onClick={() => setShowNotifications(false)} />
          <div className="relative bg-white text-black rounded-2xl shadow-xl w-[min(92vw,560px)] max-w-[560px] p-8 md:p-10 flex flex-col items-center justify-center">
            <img
              src="/icons/zzz.svg"
              alt="Keine Benachrichtigungen"
              className="mb-4 h-28 w-28 object-contain select-none pointer-events-none"
              style={{ imageRendering: 'pixelated' }}
              onError={(e) => {
                const el = e.currentTarget as HTMLImageElement;
                el.onerror = null;
                // Fallback to emoji if the local asset is missing
                el.outerHTML = '<div style="font-size:48px;line-height:1">üí§</div>';
              }}
            />
            <button onClick={() => setShowNotifications(false)} className="absolute top-3 right-3 text-black/60 hover:text-black">‚úï</button>
            <div className="text-lg font-semibold">Keine neuen Nachrichten</div>
            <div className="mt-1 text-sm text-black/60">Du bist up to date</div>
          </div>
        </div>
      )}
      {/* Test Terminal */}
      {showTest && (
        <RaffleTestTerminal
          onClose={() => {
            setShowTest(false);
            setForceRaffleWindow(false);
          }}
          forceRaffleWindow={forceRaffleWindow}
          onForceRaffleWindowChange={setForceRaffleWindow}
        />
      )}
      {/* Main viewport content: ads + center column with proportional layout */}
      <div className="relative z-10 flex-1 w-full px-4 overflow-hidden flex justify-between items-center">
        {/* Left panel: Yesterday's winners */}
        <aside className="hidden xl:flex w-[300px] flex-col gap-4 self-center -mr-4">
          <div className="w-full rounded-2xl border border-white/15 bg-white/5 backdrop-blur-[2px] text-white p-3 shadow-[0_8px_30px_rgba(0,0,0,0.35)]">
            {/* Datum und Uhrzeit der Losung */}
            <div className="text-xs text-white/60 mb-1.5 font-medium">
              {(() => {
                const yesterday = new Date();
                yesterday.setDate(yesterday.getDate() - 1);
                const berlinTime = new Intl.DateTimeFormat('de-DE', {
                  timeZone: 'Europe/Berlin',
                  day: '2-digit',
                  month: '2-digit',
                  year: 'numeric'
                }).format(yesterday);
                return `${berlinTime} ‚Ä¢ 20:00`;
              })()}
            </div>
            <div className="flex items-center justify-between mb-2">
              <div className="text-sm font-bold">
                {winnersDateLabel || 'Letzte Gewinner:'}
              </div>
              {/* Gewinner-Anzahl oben rechts: Anzahl der Children/Eintr√§ge */}
              <div className="flex items-baseline gap-1 text-xs font-semibold">
                <span className="tabular-nums">{Array.isArray(winners) ? winners.length : 0}</span>
                <span className="opacity-80">Gewinner</span>
              </div>
            </div>
            <div className={`${winners.length > 5 ? 'max-h-[195px] overflow-y-auto pr-1' : ''}`}>
              <ul className="space-y-1.5 text-[13px]">
                {winners.length === 0 ? (
                  <li className="flex items-center justify-between gap-2 rounded-xl bg-white/5 border border-white/10 px-2 py-1.5 text-white/70">
                    <span className="truncate">Noch keine Gewinne</span>
                    <span className="text-[11px]">‚Äî</span>
                  </li>
                ) : (
                  winners.map((w, i) => (
                    <li key={`w-${i}`} className="flex items-center justify-between gap-2 rounded-xl bg-white/5 border border-white/10 px-2 py-1.5">
                    <div className="flex items-center gap-2 min-w-0">
                      <img
                        src="/icons/trophy.svg"
                        alt="Trophy"
                        width={16}
                        height={16}
                        className="select-none pointer-events-none"
                        style={{ imageRendering: 'pixelated' }}
                      />
                      <span className="truncate">{w.name}</span>
                    </div>
                    <div className="flex items-center gap-2 text-right">
                      <span className="whitespace-nowrap text-white/85">{w.prize}</span>
                      <span className="text-[11px] text-white/60 tabular-nums">{w.time ?? ''}</span>
                    </div>
                  </li>
                ))
              )}
              </ul>
            </div>
          </div>
        </aside>

        {/* Center column: collage fills most, minigame pinned near bottom */}
        <div className="flex-1 h-full flex flex-col items-stretch pb-6">
          {/* Collage area (flex grows) */}
          <div
            ref={areaRef}
            onMouseMove={handleMouseMove}
            className="w-full flex-1 min-h-0 flex items-center justify-center"
          >
            <div
              className="flex flex-col items-center mt-8"
              style={{ transform: `translate(${offset.x}px, ${offset.y}px)` }}
            >
              <div
                className="self-center flex flex-col items-center justify-center mx-auto"
                style={{ maxWidth: 'min(74vw, 720px)', maxHeight: '60vh' }}
              >
                <div className="relative inline-block">
                  <div
                    aria-hidden="true"
                    className="pointer-events-none absolute inset-0 -z-10 flex items-center justify-center"
                  >
                    <div
                      className="rounded-full blur-xl opacity-95"
                      style={{
                        width: '100%',
                        height: '80%',
                        background: 'radial-gradient(circle at center, rgba(0,0,0,0.85) 0%, rgba(0,0,0,0.7) 40%, rgba(0,0,0,0.4) 65%, rgba(0,0,0,0.15) 80%, rgba(0,0,0,0) 88%)'
                      }}
                    />
                  </div>
                  {/* Drop level inline bar */}
                  {(() => {
                    const pct = poolProgress.pct;
                    return (
                      <div className="mb-2 w-[80%] max-w-sm mx-auto">
                        <div className="flex items-baseline justify-between text-sm text-white">
                          <span>
                            Level <span className="tabular-nums font-bold text-base">{Math.max(0, effectivePoolLevel)}</span>
                          </span>
                          <div className="text-right">
                            <span className="tabular-nums">{poolProgressLabel}</span> {poolProgressSuffix}
                            {poolProgressIsMax && (
                              <div className="text-[10px] uppercase tracking-wide text-white/60">Max Level erreicht</div>
                            )}
                          </div>
                        </div>
                        <div className="mt-1 h-3 rounded-full bg-black/10 overflow-hidden ring-1 ring-white/10">
                          <div
                            className="h-3 rounded-full bg-gradient-to-r from-rose-500 via-red-500 to-orange-500 transition-[width] duration-500"
                            style={{ width: `${pct}%` }}
                          />
                        </div>
                      </div>
                    );
                  })()}
                  <button
                    type="button"
                    onClick={() => { closeAllModals(); setShowPool(true); }}
                    aria-label="Collage √∂ffnen"
                    className="relative block cursor-pointer focus:outline-none focus:ring-0 rounded"
                  >
                    {url ? (
                      <img
                        src={url}
                        alt="Preise"
                        onLoad={() => { /* preloaded; no-op */ }}
                        onError={() => { setUrl('/drop-error.png'); }}
                        className="pointer-events-none block mx-auto object-contain max-w-full max-h-[60vh] drop-shadow-2xl select-none opacity-100"
                      />
                    ) : (
                      <div className="block mx-auto max-w-full max-h-[60vh] aspect-[16/9] rounded-2xl border border-white/10 bg-gradient-to-br from-neutral-200 via-white to-neutral-100 opacity-100" />
                    )}
                  </button>
                </div>
                <div className="mt-2 px-4 py-1.5 rounded-full bg-white text-black text-sm font-semibold shadow-sm border border-black/10 select-none">
                  <span className="tabular-nums">
                    {isHydrated
                      ? (() => {
                          const now = Math.floor((serverNowBaseRef.current + (performance.now() - perfBaseRef.current)) / 1000) * 1000;
                          const raffleStart = new Date(now);
                          raffleStart.setHours(20, 0, 0, 0);
                          const raffleEnd = new Date(now);
                          raffleEnd.setHours(20, 15, 0, 0);
                          const realWindow = now >= raffleStart.getTime() && now < raffleEnd.getTime();
                          const isRaffleWindow = forceRaffleWindow || realWindow;

                          if (isRaffleWindow) {
                            let msLeft = Math.max(0, raffleEnd.getTime() - now);
                            if (forceRaffleWindow && !realWindow) {
                              msLeft = 15 * 60 * 1000;
                            }
                            return (
                              <span className="flex items-center gap-2">
                                <div className="relative w-4 h-4">
                                  {/* Base circle */}
                                  <div className="absolute inset-0 border-2 border-black/30 rounded-full"></div>
                                  {/* Gravity-affected loading segment */}
                                  <div className="absolute inset-0 border-2 border-transparent border-t-black rounded-full" style={{ 
                                    animation: 'gravityRoll 2s linear infinite',
                                    transformOrigin: 'center'
                                  }}></div>
                                </div>
                                Gewinner werden gelost ‚Ä¢ {fmtMS(msLeft)}
                              </span>
                            );
                          }

                          return until20 || fmtHMS(msUntil20From(now));
                        })()
                      : "--:--:--"}
                  </span>
                </div>
              </div>
            </div>
            {error && <p className="text-sm text-white/80">{error}</p>}
          </div>

          {/* Minigame ‚Äî Neon Hologram */}
          <div className="w-full flex flex-col items-center flex-none mt-auto mb-6">
          <div className="relative aspect-[921/177] h-[clamp(120px,18vh,160px)] w-[33.33vw] max-w-full">
            <NeonHoloCard
              title={gameSlug || 'Minigame'}
              subtitle="Tippe die richtige Zelle"
              timeLabel={remaining || 'Jetzt spielen'}
              img={gameUrl || null}
              onImgLoad={() => setGameReady(true)}
              onImgError={() => setGameReady(true)}
              uid={uid}
              onShowAccount={() => { closeAllModals(); setShowAccount(true); }}
              onStart={() => {
                try {
                  const now = serverNowBaseRef.current + (performance.now() - perfBaseRef.current);
                  const snap = {
                    v: 1,
                    now,
                    coins,
                    streak,
                    ticketsToday,
                    effects,
                    avatar: profilePhoto || null,
                  };
                  sessionStorage.setItem('topbarSnapshot', JSON.stringify(snap));
                } catch {}
              }}
            />
          </div>
          </div>
        </div>

        {/* Right sidebar: Ads am rechten Rand, vertikal mittig */}
        <aside className="hidden xl:block fixed top-1/2 right-0 -translate-y-1/2 w-[300px] flex flex-col space-y-6 z-40 mr-4">
          <div className="w-full h-[250px] rounded-2xl border border-white/15 bg-gray-200 flex items-center justify-center text-white/60 text-sm">
            Ad Placeholder
          </div>
          <div className="w-full h-[250px] rounded-2xl border border-white/15 bg-gray-200 flex items-center justify-center text-white/60 text-sm">
            Ad Placeholder
          </div>
        </aside>
        {/* Right spacer to keep center truly centered when left panel is visible */}
        <div className="hidden xl:block w-[300px] self-center" aria-hidden="true" />
      </div>

      {/* Prize Pool Modal */}
      {showPool && (
        <div className="fixed inset-0 z-40 flex items-center justify-center">
          <div className="absolute inset-0 bg-black/80" onClick={() => setShowPool(false)} />
          <div className="relative bg-white text-black rounded-2xl shadow-xl w-[min(92vw,980px)] max-h-[84vh] p-4 sm:p-6 overflow-hidden">
            <div className="flex items-start justify-end gap-3">
              <button onClick={() => setShowPool(false)} className="text-black/60 hover:text-black">‚úï</button>
            </div>
            {/* Centered level bar below header: 50% modal width */}
            {(() => {
              const pct = poolProgress.pct;
              return (
                <div className="mt-2 mb-8 w-full">
                  <div className="mx-auto w-1/2">
                    <div className="flex items-baseline justify-between text-sm text-black">
                      <span>
                        Level <span className="tabular-nums font-bold text-base">{Math.max(0, effectivePoolLevel)}</span>
                      </span>
                      <div className="text-right">
                        <span className="tabular-nums">{poolProgressLabel}</span> {poolProgressSuffix}
                        {poolProgressIsMax && (
                          <div className="text-[10px] uppercase tracking-wide text-black/50">Max Level erreicht</div>
                        )}
                      </div>
                    </div>
                    <div className="mt-1 h-3 rounded-full bg-black/10 overflow-hidden ring-1 ring-white/10">
                      <div
                        className="h-3 rounded-full bg-gradient-to-r from-rose-500 via-red-500 to-orange-500 transition-[width] duration-500"
                        style={{ width: `${pct}%` }}
                      />
                    </div>
                  </div>
                  <p className="mt-2 text-center text-xs text-black/60">Sammle Tickets, um den Pool zu f√ºllen und bessere Preise freizuschalten.</p>
                </div>
              );
            })()}
            <div className="mt-4 grid grid-cols-2 sm:grid-cols-3 lg:grid-cols-4 gap-4 overflow-y-auto pr-1" style={{ maxHeight: '68vh' }}>
              {poolResolved.length === 0 && (
                <>
                  {Array.from({ length: 8 }).map((_, i) => (
                    <div key={`pp-demo-${i}`} className="relative flex flex-col items-center">
                      <div className="aspect-[64/100] w-full">
                        <GiftCard3D title="Titel">
                          <div className="absolute top-2 left-2 bg-black/70 text-white text-[11px] px-2 py-0.5 rounded-full">√ó1</div>
                        </GiftCard3D>
                      </div>
                    </div>
                  ))}
                </>
              )}
              {poolResolved.map((it, idx) => (
                <div key={idx} className="relative flex flex-col items-center">
                  <div className="aspect-[64/100] w-full">
                    <GiftCard3D title={it.title || "Titel"} img={it.url}>
                      {it.title !== 'Not disclosed' && (
                        <div className="absolute top-2 left-2 bg-black/70 text-white text-[11px] px-2 py-0.5 rounded-full">
                          √ó{scaledQty(it.qty)}
                        </div>
                      )}
                    </GiftCard3D>
                  </div>
                </div>
              ))}
            </div>
          </div>
        </div>
      )}

      {/* Daily Login Bonus */}
      <div className={`fixed inset-0 z-40 flex items-center justify-center ${showDaily ? 'opacity-100 pointer-events-auto' : 'opacity-0 pointer-events-none'}`}>
        <div className="absolute inset-0 bg-black/80" onClick={() => setShowDaily(false)} />
        <div className="relative bg-white text-black rounded-2xl shadow-xl w-[min(78vw,720px)] max-h-[86vh] p-4 sm:p-5 overflow-hidden">
            <div className="sticky top-0 z-10 bg-white pt-1 pb-2 -mx-4 sm:-mx-5 px-4 sm:px-5 flex items-start justify-end">
              <button onClick={() => setShowDaily(false)} className="text-black/60 hover:text-black">‚úï</button>
            </div>
            {/* scroll container */}
            <div className="mt-2 overflow-y-auto" style={{ maxHeight: '70vh' }}>
              {/* Streak progress 1‚Äì30 */}
              <div className="mt-3 max-w-3xl mx-auto">
                <div className="grid grid-cols-7 gap-1 items-stretch justify-items-stretch">
                {dailyRewards.map((r, i) => {
                    // 14 Tage, 2 Reihen √† 7
                    const day = i + 1; // 1..14
                    const pos = currentDailyPos(); // 1..14
                    const isToday = day === pos;         // aktuelle Kachel
                    const isDone = day <= (streak || 0); // alle Tage bis zur Serie gelten als eingel√∂st
                    return (
                      <div
                        key={i}
                        className={`relative flex flex-col items-center justify-center rounded-xl border aspect-[4/3] w-full h-full min-w-0 p-1 sm:p-1.5 text-[10px] sm:text-xs ${
                          isDone
                            ? 'bg-emerald-100 border-emerald-300'
                            : isToday
                            ? 'bg-amber-100 border-amber-300'
                            : (dailySpecialItems[day] ? 'bg-sky-50 border-sky-300' : 'bg-white border-black/10')
                        }`}
                      >
                        <div className={`text-[10px] sm:text-[11px] uppercase tracking-wide ${isToday ? 'text-amber-700' : 'text-black/50'}`}>
                          Tag {day}
                        </div>
                        {!dailySpecialItems[day] ? (
                          <div className="font-bold text-sm sm:text-base">
                            +{r}
                            <span ref={isToday ? dailySourceGemRef : undefined} className="inline-block align-middle ml-1">
                              <img
                                src="/icons/coin.svg"
                                alt="Coin"
                                width={16}
                                height={16}
                                className="inline-block select-none pointer-events-none align-middle"
                                style={{ imageRendering: 'pixelated', verticalAlign: '-0.125em' }}
                                onError={(e) => {
                                  const el = e.currentTarget as HTMLImageElement;
                                  if (!el.dataset.fallback) {
                                    el.dataset.fallback = 'png';
                                    el.src = '/icons/coin.png';
                                  } else {
                                    el.outerHTML = '<span aria-hidden="true" style="font-size:14px;line-height:1">ü™ô</span>';
                                  }
                                }}
                              />
                            </span>
                          </div>
                        ) : (
                          <div className="mt-0.5 text-[10px] sm:text-[11px] font-semibold text-emerald-700 flex items-center gap-1">
                            <span aria-hidden>{dailySpecialItems[day].emoji}</span>
                            <span>{dailySpecialItems[day].label}</span>
                          </div>
                        )}
                        {isDone && (
                          <div className="absolute -top-2 -right-2 bg-emerald-500 text-white text-[10px] px-1.5 py-0.5 rounded-full">
                            Eingel√∂st
                          </div>
                        )}
                      </div>
                    );
                  })}
                </div>
              </div>
            </div>
            {/* Claim row (moved outside scroll container, always visible at bottom of modal card) */}
            {/* invisible anchor near claim area for gem spawn */}
            <div ref={testAnchorRef} className="sr-only" aria-hidden />
            <div className="mt-4 sm:mt-6 flex items-center justify-center gap-3">
              <button
                disabled={!uid || claimedToday || claimLoading}
                className={`px-4 py-2 rounded-full text-white font-semibold ${(!uid || claimedToday || claimLoading) ? 'bg-black/30 cursor-not-allowed' : 'bg-black hover:opacity-90'}`}
                onClick={() => {
                  const n = todaysRewardCount();
                  playGemFly(n, dailySourceGemRef.current);
                  handleClaim();
                }}
              >
                {claimedToday ? 'Heute bereits abgeholt' : (claimLoading ? 'Wird abgeholt‚Ä¶' : 'Heute abholen')}
              </button>
              {claimError && (
                <div className="mt-2 text-xs text-red-600 font-semibold">
                  {claimError}
                </div>
              )}
            </div>
          </div>
        </div>
      </div>

      {/* Account Modal */}
      {showAccount && (
        <div className="fixed inset-0 z-40 flex items-center justify-center">
          <div className="absolute inset-0 bg-black/80" onClick={() => { if (!mustComplete) setShowAccount(false); }} />
          <div className="relative bg-transparent text-black w-[min(92vw,480px)] max-h-[85vh] p-0 overflow-visible">
            <button onClick={() => { if (!mustComplete) setShowAccount(false); }} className="absolute top-3 right-3 z-10 text-white/70 hover:text-white">‚úï</button>
            <div className="w-full max-h-[calc(85vh-2rem)] overflow-y-auto">
              {/* <AccountPanel embedded /> */}
              <div className="text-center p-8">Account Panel tempor√§r deaktiviert</div>
            </div>
          </div>
        </div>
      )}
      {/* Items Modal */}
      {showItems && (
        <div className="fixed inset-0 z-40 flex items-center justify-center">
          <div className="absolute inset-0 bg-black/80" onClick={() => setShowItems(false)} />
          <div className="relative bg-white text-black rounded-2xl shadow-xl w-[min(92vw,480px)] max-h-[80vh] px-6 pb-6 pt-12 overflow-y-auto">
          <button onClick={() => setShowItems(false)} className="absolute top-3 right-3 text-black/60 hover:text-black">‚úï</button>
          <div className="space-y-3">
            {buyError && <div className="p-2 text-sm text-red-700 bg-red-50 border border-red-200 rounded">{buyError}</div>}
            {shopItems.filter(it => (it.active ?? true)).map((it) => {
                const owned = itemsOwned[it.id] || 0; // echte Anzahl
                const canBuy = (coins || 0) >= it.price && owned < 1; // kaufen nur, wenn noch keins
                const busy = buyBusy[it.id];
                const nowMs = nowMsItems || Date.now();
                const eff = effects[it.id];
                const isActive = !!eff?.active && typeof eff?.untilMs === 'number' && eff.untilMs > nowMs;
                const remMs = isActive && eff?.untilMs ? Math.max(0, eff.untilMs - nowMs) : 0;
                const remLabel = isActive && eff?.untilMs ? fmt(remMs) : null;
                return (
                  <div
                    key={it.id}
                    className={`p-4 border rounded-2xl flex items-center justify-between gap-3 ${isActive ? 'bg-emerald-100 border-emerald-300 active-glow active-anim active-bling' : 'bg-white border-black/10'}`}
                  >
                    <div className="flex items-center gap-3 min-w-0">
                      <img
                        src={it.id === 'ad_20_coins' ? '/icons/free-coins.svg' : `/icons/${it.id}.svg`} 
                        alt=""
                        width={40}
                        height={40}
                        onError={(e) => {
                          const el = e.currentTarget as HTMLImageElement;
                          el.onerror = null;
                          el.src = it.id === 'ad_20_coins' ? '/icons/free-coins.svg' : '/items/pixel-items.svg';
                        }}
                        className="w-10 h-10 object-contain select-none"
                        style={{ imageRendering: 'pixelated' }}
                      />
                      <div className="min-w-0">
                        <div className="font-semibold truncate">{it.name}</div>
                        <div className="text-sm text-gray-700 truncate">{it.desc}</div>
                        {it.id !== 'ad_20_coins' && (
                          <div className="mt-1 text-xs text-gray-700">
                            Besitz: <span className="tabular-nums">{owned}</span>
                          </div>
                        )}
                      </div>
                    </div>
                    <div className="flex items-center gap-2">
                      {isActive ? (
                        <span className="px-3 py-1.5 rounded-full text-[12px] font-semibold bg-black text-white border border-emerald-700 tabular-nums">
                          Aktiv{remLabel ? ` ¬∑ ${remLabel}` : ''}
                        </span>
                      ) : owned < 1 ? (
                        <button
                          onClick={() => buyItem(it.id)}
                          disabled={!uid || busy || !canBuy}
                          className={`px-3 py-1.5 rounded-full text-white text-sm font-semibold flex items-center gap-1.5 ${(!uid || busy || !canBuy) ? 'bg-black/30 cursor-not-allowed' : 'bg-black hover:opacity-90'}`}
                        >
                          {it.id === 'ad_20_coins' && (
                            <img
                              src="/icons/ad-icon.svg"
                              width={12} // von 14 auf 12 reduziert
                              height={12} // von 14 auf 12 reduziert 
                              alt=""
                              className="opacity-90"
                            />
                          )}
                          {it.price}
                          <img
                            src="/icons/coin.svg"
                            width={18}
                            height={18}
                            alt="Coins"
                            className="inline-block align-middle"
                            style={{ imageRendering: 'pixelated', verticalAlign: '-0.18em' }}
                          />
                        </button>
                      ) : (
                        <button
                          onClick={() => useItem(it.id)}
                          disabled={!uid || busy}
                          className={`px-3 py-1.5 rounded-full text-white text-sm font-semibold ${(!uid || busy) ? 'bg-black/30 cursor-not-allowed' : 'bg-black hover:opacity-90'}`}
                        >
                          {busy ? 'Verwenden‚Ä¶' : 'Verwenden'}
                        </button>
                      )}
                    </div>
                  </div>
                );
              })}
            </div>
          </div>
        </div>
      )}
      {/* Styles temporarily removed to fix build */}
      {/* CSS content removed from here through line with Confetti */}
        }
        .active-glow::after{
          content:"";
          position:absolute; inset:-2px;
          border-radius: 1rem; /* match rounded-2xl */
          box-shadow: 0 0 0 0 rgba(16,185,129,0.0), 0 0 0 0 rgba(16,185,129,0.0), 0 0 0 0 rgba(16,185,129,0.0);
          pointer-events:none;
          animation: activePulse 1.8s ease-in-out infinite;
        }
        @keyframes activePulse {
          0%   { box-shadow: 0 0 0 0 rgba(16,185,129,0.55), 0 0 24px 0 rgba(16,185,129,0.35), inset 0 0 0 0 rgba(16,185,129,0.0); }
          50%  { box-shadow: 0 0 0 6px rgba(16,185,129,0.00), 0 0 32px 4px rgba(16,185,129,0.45), inset 0 0 0 0 rgba(16,185,129,0.0); }
          100% { box-shadow: 0 0 0 0 rgba(16,185,129,0.55), 0 0 24px 0 rgba(16,185,129,0.35), inset 0 0 0 0 rgba(16,185,129,0.0); }
        }
        /* stronger visible animation */
        .active-anim { animation: activeBgPulse 1.4s ease-in-out infinite; }
        @keyframes activeBgPulse { 0%,100%{ transform: scale(1); } 50%{ transform: scale(1.02); } }
        
        /* Smooth circular roll animation for loading circle */
        @keyframes gravityRoll {
          0% { transform: rotate(0deg); }
          100% { transform: rotate(360deg); }
        }
        
        /* Performance test spinner */
        .test-spinner {
          border: 2px solid rgba(255, 255, 255, 0.3);
          border-left: 2px solid #ffffff;
          border-radius: 50%;
          animation: spin 1s linear infinite;
        }
        @keyframes spin {
          0% { transform: rotate(0deg); }
          100% { transform: rotate(360deg); }
        }
        .active-bling{ position: relative; }
        .active-bling::before{
          content:""; position:absolute; inset:0; border-radius:1rem; /* match rounded-2xl */ pointer-events:none;
          background: linear-gradient(120deg, transparent 0%, rgba(255,255,255,0.6) 45%, transparent 90%);
          transform: translateX(-120%);
          animation: ctaShine 2.4s ease-in-out infinite;
        }
        @keyframes holoBorder { from { filter: hue-rotate(0deg); } to { filter: hue-rotate(360deg); } }
        .no-scrollbar { scrollbar-width: none; }
        .no-scrollbar::-webkit-scrollbar { display: none; }
  // removed generic .ticker-* rules (small-ticker uses its own styles)
        :global(.animate-cta-shine) { position: relative; overflow: hidden; }
        :global(.animate-cta-shine)::after {
          content: "";
          position: absolute;
          inset: 0;
          background: linear-gradient(120deg, transparent 0%, rgba(255,255,255,0.6) 45%, transparent 90%);
          transform: translateX(-120%);
          animation: ctaShine 2.4s ease-in-out infinite;
        }
        /* --- skeleton placeholders for Prize Pool --- */
        :global(.skeleton-shine){
          position: relative;
          background: linear-gradient(90deg, rgba(0,0,0,0.06) 25%, rgba(0,0,0,0.12) 37%, rgba(0,0,0,0.06) 63%);
          background-size: 400% 100%;
          animation: skeletonLoading 1.1s ease-in-out infinite;
        }
        :global(.skeleton-shine\/soft){
          position: relative;
          background: linear-gradient(90deg, rgba(0,0,0,0.04) 25%, rgba(0,0,0,0.08) 37%, rgba(0,0,0,0.04) 63%);
          background-size: 400% 100%;
          animation: skeletonLoading 1.1s ease-in-out infinite;
        }
        @keyframes skeletonLoading {
          0% { background-position: 100% 50%; }
          100% { background-position: 0% 50%; }
        }
        /* 3D tilt for the hologram card */
        :global(.holo .card) { transform: rotateX(calc(var(--rx,0) * 1deg)) rotateY(calc(var(--ry,0) * 1deg)); transform-style: preserve-3d; transition: transform 120ms ease; }
        :global(.gift .gift-card){ transform: rotateX(calc(var(--rx,0) * 1deg)) rotateY(calc(var(--ry,0) * 1deg)); transform-style: preserve-3d; transition: transform 120ms ease; }
        :global(.gift .parallax){
          transform: translate3d(var(--tx,0px), var(--ty,0px), var(--dz,0));
          transition: transform 120ms ease;
        }
        @keyframes holoBorder { from { filter: hue-rotate(0deg); } to { filter: hue-rotate(360deg); } }
        .no-scrollbar { scrollbar-width: none; }
        .no-scrollbar::-webkit-scrollbar { display: none; }
  // removed duplicate generic .ticker-* rules
        :global(.animate-cta-shine) { position: relative; overflow: hidden; }
        :global(.animate-cta-shine)::after {
          content: "";
          position: absolute;
          inset: 0;
          background: linear-gradient(120deg, transparent 0%, rgba(255,255,255,0.6) 45%, transparent 90%);
          transform: translateX(-120%);
          animation: ctaShine 2.4s ease-in-out infinite;
        }
        /* --- scanlines overlay --- */
        :global(.scanlines){
          pointer-events:none;
          background-image:repeating-linear-gradient(to bottom, rgba(255,255,255,0.6) 0 1px, transparent 1px 3px);
          background-size:100% 3px;
          opacity:0.07;
          animation:scanDrift 12s linear infinite;
        }
        @keyframes scanDrift{0%{background-position:0 0}100%{background-position:0 12px}}
        @media (prefers-reduced-motion: reduce){ :global(.scanlines){ animation:none !important; } }
        /* --- drop logo animation --- */
        :global(.drop-logo) {
          transform-origin: left center;
          backface-visibility: hidden;
          will-change: transform;
          transform: translateZ(0);
        }
        /* six variants; each animates early, then idles */
        :global(.drop-anim-0) { animation: dropLogoA 20s cubic-bezier(.22,.61,.36,1) infinite; }
        :global(.drop-anim-1) { animation: dropLogoB 20s cubic-bezier(.22,.61,.36,1) infinite; }
        :global(.drop-anim-2) { animation: dropLogoC 20s cubic-bezier(.22,.61,.36,1) infinite; }
        :global(.drop-anim-3) { animation: dropLogoD 20s cubic-bezier(.22,.61,.36,1) infinite; }
        :global(.drop-anim-4) { animation: dropLogoE 20s cubic-bezier(.22,.61,.36,1) infinite; }
        :global(.drop-anim-5) { animation: dropLogoG 20s cubic-bezier(.22,.61,.36,1) infinite; }

        @keyframes dropLogoA {
          0%   { transform: translateY(0) rotate(0deg) scale(1); }
          2%   { transform: translateY(-1.5px) rotate(-2deg) scale(1.04); }
          4%   { transform: translateY(0) rotate(0deg) scale(1); }
          6%   { transform: translateY(1.5px) rotate(2deg) scale(1.03); }
          8%   { transform: translateY(0) rotate(0deg) scale(1); }
          100% { transform: translateY(0) rotate(0deg) scale(1); }
        }
        @keyframes dropLogoB {
          0%   { transform: translateX(0) skewX(0deg) scale(1); }
          2%   { transform: translateX(2px) skewX(6deg)  scale(1.03); }
          4%   { transform: translateX(-1px) skewX(-4deg) scale(1.02); }
          6%   { transform: translateX(1px) skewX(2deg)  scale(1.01); }
          8%   { transform: translateX(0) skewX(0deg)  scale(1); }
          100% { transform: translateX(0) skewX(0deg)  scale(1); }
        }
        @keyframes dropLogoC {
          0%   { transform: scale(1) rotate(0deg); filter: brightness(1) saturate(1) drop-shadow(0 0 0 rgba(255,255,255,0)); }
          2.5% { transform: scale(1.06) rotate(0.5deg); filter: brightness(1.6) saturate(1.2) drop-shadow(0 0 10px rgba(255,255,255,0.6)); }
          5%   { transform: scale(1) rotate(0deg);   filter: brightness(1) saturate(1) drop-shadow(0 0 0 rgba(255,255,255,0)); }
          100% { transform: scale(1) rotate(0deg);   filter: brightness(1) saturate(1) drop-shadow(0 0 0 rgba(255,255,255,0)); }
        }
        @keyframes dropLogoD {
          0%   { transform: translateY(0) scale(1); filter: brightness(1); }
          3%   { transform: translateY(-3px) scale(1.06); filter: brightness(1.3); }
          6%   { transform: translateY(0) scale(1.02); }
          9%   { transform: translateY(-2px) scale(1.04); }
          12%  { transform: translateY(0) scale(1); }
          100% { transform: translateY(0) scale(1); }
        }
        @keyframes dropLogoE {
          0%   { transform: rotate(0deg) scale(1); filter: drop-shadow(0 0 0 rgba(255,255,255,0)); }
          2.5% { transform: rotate(-2deg) scale(1.03); filter: drop-shadow(0 0 8px rgba(255,255,255,0.5)); }
          5%   { transform: rotate(2deg) scale(1.02); }
          7.5% { transform: rotate(0deg) scale(1); }
          100% { transform: rotate(0deg) scale(1); }
        }
        @keyframes dropLogoG {
          0%   { filter: blur(0px) contrast(1) saturate(1); }
          2%   { filter: blur(1.2px) contrast(1.12) saturate(1.18); }
          4%   { filter: blur(0px) contrast(1.06) saturate(1.06); }
          6%   { filter: blur(0px) contrast(1) saturate(1); }
          100% { filter: blur(0px) contrast(1) saturate(1); }
        }

        /* Small ticker animation */
        :global(.small-ticker-wrap) { 
          position: relative; 
          overflow: hidden;
          backface-visibility: hidden;
          will-change: transform;
        }
        :global(.small-ticker-track) { 
          display: inline-block;
          white-space: nowrap;
          /* RAF-driven: disable CSS animation to avoid conflicts */
          animation: none !important;
          backface-visibility: hidden;
          will-change: transform;
          transform: translateZ(0);
          position: relative;
          height: 100%;
        }
        /* keyframes removed: ticker is RAF-driven */

        :global(.small-ticker-text) {
          position: absolute;
          left: 0;
          top: 50%;
          transform: translateY(-50%);
          white-space: nowrap;
          will-change: transform;
        }

        @media (prefers-reduced-motion: reduce) {
          :global(.drop-logo), :global(.drop-anim-0), :global(.drop-anim-1), :global(.drop-anim-2), :global(.drop-anim-3), :global(.drop-anim-4), :global(.drop-anim-5) { animation: none !important; }
          :global(.small-ticker-track) { animation: none !important; }
        */}
      {/* Styles end */}
      {/* Confetti burst overlay */}
      {confettiAt !== 0 && (
        <ConfettiBurst onDone={() => { setConfettiAt(0); }} />
      )}
      
      {/* Second page below: full-screen black */}
      <section className="relative w-screen h-screen bg-red-500 snap-start snap-always">
        <div className="h-full" />
      </section>
      
      {/* Footer Section */}
      <section ref={footerSectionRef} className="relative w-screen h-screen bg-red-500 text-white snap-start snap-always">
      <div className="h-full flex flex-col justify-between">
        {/* FAQ Section */}
        <div className="flex-1 flex items-center justify-center py-12">
          <div className="max-w-4xl mx-auto px-4">
            <h2 className="text-3xl font-bold text-center mb-12">H√§ufig gestellte Fragen</h2>
            <div className="space-y-4">
              {/* FAQ Item 1 */}
              <div className="w-full flex justify-center">
                <div className="bg-white/90 rounded-lg w-full box-border overflow-hidden" style={{ width: 'min(86vw,980px)' }}>
                  <button
                    className="w-full px-6 py-4 text-left flex justify-between items-center"
                    onClick={() => setOpenFaq(openFaq === 1 ? null : 1)}
                    aria-expanded={openFaq === 1}
                    aria-controls="faq-1"
                  >
                    <span className="font-semibold text-black">Wie kann ich Coins verdienen?</span>
                    <span className={`transition-transform duration-200 text-black ${openFaq === 1 ? 'rotate-180' : 'rotate-0'}`}>‚ñº</span>
                  </button>
                  <div id="faq-1" className="px-6 pb-4 text-black/80" style={{ display: openFaq === 1 ? 'block' : 'none' }}>
                    Du kannst Coins durch das Spielen von Minigames, t√§gliche Logins und das Abschlie√üen verschiedener Aufgaben verdienen. Jede Aktivit√§t bringt dir unterschiedlich viele Coins ein.
                  </div>
                </div>
              </div>

              {/* FAQ Item 2 */}
              <div className="w-full flex justify-center">
                <div className="bg-white/90 rounded-lg w-full box-border overflow-hidden" style={{ width: 'min(86vw,980px)' }}>
                  <button
                    className="w-full px-6 py-4 text-left flex justify-between items-center"
                    onClick={() => setOpenFaq(openFaq === 2 ? null : 2)}
                    aria-expanded={openFaq === 2}
                    aria-controls="faq-2"
                  >
                    <span className="font-semibold text-black">Was sind Tickets und wie funktionieren sie?</span>
                    <span className={`transition-transform duration-200 text-black ${openFaq === 2 ? 'rotate-180' : 'rotate-0'}`}>‚ñº</span>
                  </button>
                  <div id="faq-2" className="px-6 pb-4 text-black/80" style={{ display: openFaq === 2 ? 'block' : 'none' }}>
                    Tickets sind deine Eintrittskarten f√ºr die t√§glichen Verlosungen. Je mehr Tickets du hast, desto h√∂her sind deine Gewinnchancen bei den Preisverlosungen.
                  </div>
                </div>
              </div>

              {/* FAQ Item 3 */}
              <div className="w-full flex justify-center">
                <div className="bg-white/90 rounded-lg w-full box-border overflow-hidden" style={{ width: 'min(86vw,980px)' }}>
                  <button
                    className="w-full px-6 py-4 text-left flex justify-between items-center"
                    onClick={() => setOpenFaq(openFaq === 3 ? null : 3)}
                    aria-expanded={openFaq === 3}
                    aria-controls="faq-3"
                  >
                    <span className="font-semibold text-black">Wie funktioniert die Streak?</span>
                    <span className={`transition-transform duration-200 text-black ${openFaq === 3 ? 'rotate-180' : 'rotate-0'}`}>‚ñº</span>
                  </button>
                  <div id="faq-3" className="px-6 pb-4 text-black/80" style={{ display: openFaq === 3 ? 'block' : 'none' }}>
                    Deine Streak zeigt an, wie viele Tage hintereinander du dich eingeloggt hast. Je l√§nger deine Streak, desto bessere Belohnungen erh√§ltst du f√ºr deine t√§glichen Aktivit√§ten.
                  </div>
                </div>
              </div>

              {/* FAQ Item 4 */}
              <div className="w-full flex justify-center">
                <div className="bg-white/90 rounded-lg w-full box-border overflow-hidden" style={{ width: 'min(86vw,980px)' }}>
                  <button
                    className="w-full px-6 py-4 text-left flex justify-between items-center"
                    onClick={() => setOpenFaq(openFaq === 4 ? null : 4)}
                    aria-expanded={openFaq === 4}
                    aria-controls="faq-4"
                  >
                    <span className="font-semibold text-black">Wann werden die Gewinner bekannt gegeben?</span>
                    <span className={`transition-transform duration-200 text-black ${openFaq === 4 ? 'rotate-180' : 'rotate-0'}`}>‚ñº</span>
                  </button>
                  <div id="faq-4" className="px-6 pb-4 text-black/80" style={{ display: openFaq === 4 ? 'block' : 'none' }}>
                    Die Gewinner werden t√§glich um 20:00 Uhr MEZ gezogen und bekannt gegeben. Du wirst benachrichtigt, falls du gewonnen hast.
                  </div>
                </div>
              </div>
            </div>
          </div>
        </div>
        <footer className="bg-black text-white py-6">
          <div className="max-w-6xl mx-auto px-4">
            <div className="grid grid-cols-1 md:grid-cols-3 gap-6">
              <div>
                <h3 className="text-base font-semibold mb-2">
                  <img src="/logo.png" alt="DROP" className="h-6 object-contain inline-block" />
                </h3>
                <p className="text-gray-400 text-sm">
                  Deine Plattform f√ºr Gaming-Rewards und Preise.
                </p>
              </div>
              
              <div>
                <h4 className="text-sm font-semibold mb-2">Links</h4>
                <ul className="space-y-1 text-sm text-gray-400">
                  <li><a href="/datenschutz" className="hover:text-white transition-colors">Datenschutz</a></li>
                  <li><a href="/impressum" className="hover:text-white transition-colors">Impressum</a></li>
                  <li><a href="/agb" className="hover:text-white transition-colors">AGB</a></li>
                  <li><a href="#" className="hover:text-white transition-colors">Support</a></li>
                </ul>
              </div>
              
              <div>
                <h4 className="text-sm font-semibold mb-2">Community</h4>
                <ul className="space-y-1 text-sm text-gray-400">
                  <li><a href="#" className="hover:text-white transition-colors">Discord</a></li>
                  <li><a href="#" className="hover:text-white transition-colors">Twitter</a></li>
                  <li><a href="#" className="hover:text-white transition-colors">Instagram</a></li>
                </ul>
              </div>
            </div>
            
            <div className="border-t border-gray-800 mt-4 pt-4">
              <div className="flex flex-col md:flex-row justify-between items-center">
                <p className="text-gray-500 text-xs">
                  ¬© {new Date().getFullYear()} DROP. Alle Rechte vorbehalten.
                </p>
                <p className="text-gray-500 text-xs mt-2 md:mt-0">
                  Made with ‚ù§Ô∏è for Gamers
                </p>
              </div>
            </div>
          </div>
        </footer>
      </div>
    </section>
    </>
  );
}
